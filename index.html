<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šAIè§’è‰²ç¾¤èŠ</title>
    <!-- Vditor for Markdown preview -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vditor@3.11.2/dist/index.css" />
    <script src="https://cdn.jsdelivr.net/npm/vditor@3.11.2/dist/method.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100dvh;
            overflow: hidden;
        }

        .sidebar-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.35);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 900;
        }

        .sidebar-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .container {
            display: flex;
            height: 100dvh;
            max-width: 1800px;
            margin: 0 auto;
            gap: 16px;
            padding: 16px;
        }

        .sidebar {
            width: 280px;
            background: white;
            border-radius: var(--radius);
            padding: 16px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .sidebar-right {
            width: 300px;
            background: white;
            border-radius: var(--radius);
            padding: 16px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: var(--radius);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        /* ===== Welcome section ===== */
        .welcome-screen { display: flex; flex-direction: column; align-items: center; gap: 14px; padding: 26px 0 }
        .welcome-logo { font-size: 108px; font-weight: 300; line-height: 1.0; letter-spacing: .04em; color: var(--panel); }

        /* Two-column table-like layout for actions */
        .welcome-actions { display: grid; grid-template-columns: 1fr 1fr; column-gap: 16px; row-gap: 8px; align-items: start; max-width: 720px; margin: 8px auto 0; }
        .welcome-actions .wa-desc { text-align: right; color: color-mix(in oklab, var(--text) 30%, transparent); margin-top: 6px; }
        .welcome-actions .wa-action { text-align: left; display: flex; flex-wrap: wrap; gap: 8px; }
        .welcome-actions button { color: color-mix(in oklab, var(--text) 55%, transparent); font-size: 85%;}

        h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }

        h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }

        /* åŒæ ·ï¼Œåªé’ˆå¯¹å¤–éƒ¨é“¾æ¥ */
        /*
        * è¿™æ˜¯ä¸€ä¸ªæ™ºèƒ½é€‰æ‹©å™¨ï¼Œå®ƒä¼šåŒ¹é…æ‰€æœ‰æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„ <a> æ ‡ç­¾ï¼š
        * 1. é“¾æ¥åœ¨æ–°çª—å£æ‰“å¼€ (target="_blank")
        * 2. æˆ–è€…æ˜¯ "http" æˆ– "https" å¼€å¤´çš„ç»å¯¹è·¯å¾„
        * 3. å¹¶ä¸” (AND) é“¾æ¥çš„åŸŸå *ä¸æ˜¯* "your-website.com" (è¯·æ›¿æ¢æˆæ‚¨è‡ªå·±çš„åŸŸå)
        * * è¿™æ ·å¯ä»¥ç¡®ä¿åªä¸ºâ€œçœŸæ­£çš„â€å¤–éƒ¨é“¾æ¥æ·»åŠ å›¾æ ‡ï¼Œè€Œå†…éƒ¨é“¾æ¥ä¸å—å½±å“ã€‚
        */
        /* a[target="_blank"],
        a[href^="http"]:not([href*="your-website.com"]), */
        a {
            /* ä¸ºå›¾æ ‡æµå‡ºç©ºé—´ */
            padding-right: 1.3em; 
            /* å°†å›¾æ ‡å®šä½åˆ°å³ä¾§ */
            position: relative; 
            color: var(--text);
            text-decoration: auto;
        }

        /* a:not([href*="your-website.com"])::after, */
        a::after {
            /* 1. åˆ›å»ºä¸€ä¸ªç©ºå†…å®¹çš„ä¼ªå…ƒç´  */
            content: '';
            
            /* 2. è®¾ç½®å›¾æ ‡å°ºå¯¸ (ä½¿ç”¨ em å•ä½ï¼Œä½¿å…¶éšå­—ä½“å¤§å°ç¼©æ”¾) */
            width: 1em;
            height: 1em;

            /* 3. å®šä½åˆ° padding-right ç•™å‡ºçš„ç©ºé—´ä¸­ */
            position: absolute;
            right: 0.25em;
            bottom: 0.05em; /* å¯å¾®è°ƒå‚ç›´ä½ç½® */

            /* 4. å…³é”®ï¼šä½¿ç”¨ currentColor å¡«å……ï¼Œä½¿å…¶é¢œè‰²ä¸ <a> æ ‡ç­¾ä¸€è‡´ */
            background-color: currentColor; 

            /* 5. å…³é”®ï¼šä½¿ç”¨å†…è”çš„ SVG ä½œä¸ºè’™ç‰ˆ (è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„â€œå¤–éƒ¨é“¾æ¥â€å›¾æ ‡) */
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill-rule='evenodd' d='M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6v2H5v11h11v-6h2Z'/%3E%3Cpath fill-rule='evenodd' d='M15 3h6v6h-2V5.414l-7.293 7.293-1.414-1.414L17.586 4H15V3Z'/%3E%3C/svg%3E");
            
            /* ç¡®ä¿è’™ç‰ˆè¢«æ­£ç¡®ç¼©æ”¾ */
            mask-size: contain;
            mask-repeat: no-repeat;
        }

        .user-bar {
            background: #f0f4ff;
            padding: 12px;
            border-radius: var(--radius-sm);
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-info {
            font-size: 14px;
            color: #333;
        }

        .list-container {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .item {
            background: #f5f5f5;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .item:hover {
            background: #e8e8e8;
        }

        .item.active {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .item-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .item-desc {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .item-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .item-header { display:flex; align-items:center; justify-content:space-between; gap:8px; }
        .icon-btn { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius-sm); width: 32px; height: 32px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition: background var(--transition), border-color var(--transition), transform var(--transition), color var(--transition); }
        .icon-btn:hover { background: var(--muted); }
        .icon-btn:active { transform: scale(0.98); }
        .icon-btn:focus-visible { outline: none; box-shadow: var(--focus-ring); }
        .icon-btn-danger { background: var(--danger-soft-bg); border-color: var(--danger-soft-border); color: var(--danger-soft-fg); }
        .icon-btn-danger:hover { background: var(--danger-soft-bg-hover); }
        .icon-btn-danger:active { background: var(--danger-soft-bg-active); }
        .more-wrap { position: relative; }
        .dropdown-menu { position: absolute; right: 0; top: 36px; background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius-sm); box-shadow: var(--shadow-md); min-width: 120px; padding: 6px; z-index: 20; display: none; }
        .dropdown-menu.open { display: block; }
        .dropdown-item { padding: 8px 10px; border-radius: var(--radius-xs); cursor: pointer; font-size: 14px; color: var(--text); }
        .dropdown-item:hover { background: var(--muted); }
        .dropdown-item-danger { background: var(--danger-soft-bg); color: var(--danger-soft-fg); border: 1px solid var(--danger-soft-border); }
        .dropdown-item-danger:hover { background: var(--danger-soft-bg-hover); }
        .dropdown-item-danger:active { background: var(--danger-soft-bg-active); }
        .role-muted { color: color-mix(in oklab, var(--text) 55%, transparent); font-size: 0.9em; }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: var(--radius-xs);
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .btn-icon {
            display: inline-block;
            /* font-size: 16px; */
            margin-right: 8px;
            line-height: 1;
        }

        .btn-text {
            display: inline-block;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
            font-size: 12px;
            padding: 4px 8px;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
            font-size: 12px;
            padding: 4px 8px;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .chat-header {
            padding: 18px 24px;
            border-bottom: 1px solid #e0e0e0;
            background: #f7f9ff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            min-width: 0;
        }

        .chat-header-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }

        .chat-header-info h2 {
            margin: 0;
            font-size: 20px;
            color: #1f2937;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-header-subtitle {
            font-size: 12px;
            color: #6b7280;
            display: none;
        }

        .chat-header-left .sidebar-toggle {
            margin-right: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f9fafb;
        }

        /* ç³»ç»Ÿæç¤ºï¼ˆå…ƒä¿¡æ¯/ä¸Šä¸‹æ–‡é”šç‚¹ï¼‰æ ·å¼ */
        .system-message {
            text-align: center;
            font-size: 12px;
            color: #6b7280;
            margin: 14px 0;
            line-height: 1.4;
            padding: 0 8px;
            /* è¿™æ˜¯æ¨èçš„æ ‡å‡†æ–¹å¼ */
            overflow-wrap: break-word;
            /* ä¸ºäº†å…¼å®¹æ—§ç‰ˆæµè§ˆå™¨ */
            word-wrap: break-word;
        }
        .system-message.system-info { color: #64748b; }
        .system-message.system-success { color: #16a34a; }
        .system-message.system-warning { color: #b45309; }
        .system-message.system-error { color: #b91c1c; }

        .message {
            margin-bottom: 20px;
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
            position: sticky;
            top: 0px;
            align-self: flex-start;
        }

        .message-content {
            flex: 1;
            max-width: calc(100% - 40px);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        /* å·¥å…·æ¡ç»„ä»¶ï¼ˆå¤åˆ¶ / å¯¼å‡ºï¼‰ */
        .message-tools { background: var(--panel); border-radius: var(--radius-sm); margin-left: auto; display: flex; gap: 2px; padding: 2px; opacity: 0; pointer-events: none; transition: opacity var(--transition); }
        /* æ¡Œé¢ç«¯ï¼šæ‚¬åœæ¶ˆæ¯æ—¶åŠé€æ˜å¯è§ï¼Œæ‚¬åœå·¥å…·æ¡æœ¬ä½“æ—¶å…¨ä¸é€æ˜ */
        .message-content:hover .message-tools { opacity: .35; pointer-events: auto; }
        .message-content:hover .message-tools:hover { opacity: 1; }
        /* ç§»åŠ¨ç«¯ç‚¹å‡»æ˜¾ç¤ºï¼ˆä¸å— hover å½±å“ï¼‰ */
        .message-content.show-tools .message-tools { opacity: 1; pointer-events: auto; }
        .message-tools .icon-btn { width: 24px; height: 24px; border: none; }

        /* TTS read button */
        .tts-read-btn { position: absolute; top: 6px; right: 6px; width: 24px; height: 24px; border: 1px solid var(--border); background: var(--panel); color: var(--text); border-radius: 6px; opacity: 0; pointer-events: none; display: inline-flex; align-items: center; justify-content: center; line-height: 1; box-shadow: var(--shadow-sm); }
        .message-text:hover .tts-read-btn { opacity: 1; pointer-events: auto; }
        .tts-read-btn.loading { opacity: 1; pointer-events: auto; }
        /* TTS progress bar (inline, stick to bubble bottom like border) */
        .message-text { position: relative; }
        .message-text .tts-progress-inline { position: absolute; padding: 0 6px; left: 0; right: 0; bottom: 0; height: 3px; background: var(--border); border-radius: var(--radius-sm); overflow: hidden; pointer-events: none; }
        .message-text .tts-progress-inline .fill { height: 100%; width: 0%; background: var(--brand); transition: width 80ms linear; }
        /* Mobile: show with existing show-tools state to avoid extra handlers */
        .message-content.show-tools .message-text:active .tts-read-btn { opacity: 1; pointer-events: auto; }

        @media (max-width: 768px) {
            /* ç§»åŠ¨ç«¯ç‚¹å‡»æ˜¾ç¤ºï¼ˆä¸å—æ¡Œé¢ç«¯ hover å½±å“ï¼‰ */
            .message-content:not(.show-tools):hover .message-tools { opacity: 0; }
        }

        .message-name {
            font-weight: 600;
            color: #333;
        }

        .message-time {
            font-size: 12px;
            color: #999;
        }

        .message-text {
            background: white;
            padding: 12px;
            border-radius: var(--radius-sm);
            color: #333;
            line-height: 1.5;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            white-space: pre-wrap;
            word-break: break-word;
            position: relative;
        }

        /* æ¶ˆæ¯çŠ¶æ€ + æ“ä½œï¼ˆåˆå¹¶ç»„ä»¶ï¼‰ */
        .message-status {
            margin-left: 6px;
            padding: 2px 6px;
            border: 1px solid var(--border);
            border-radius: 999px;
            font-size: 12px;
            color: color-mix(in oklab, var(--text) 60%, transparent);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .message-status .ms-action {
            appearance: none;
            border: 0;
            background: transparent;
            color: inherit;
            cursor: pointer;
            padding: 0 2px;
            line-height: 1;
            border-radius: var(--radius-xs);
            font-size: 1.5em;
        }
        .message-status .ms-action:hover { color: var(--text); }
        .message-status .dots { display: inline-flex; gap: 2px; margin-left: 2px; vertical-align: middle; }
        .message-status .dots i { width: 4px; height: 4px; border-radius: 50%; background: currentColor; opacity: .6; display: inline-block; animation: msDots 1.2s infinite ease-in-out; }
        .message-status .dots i:nth-child(2) { animation-delay: .2s; }
        .message-status .dots i:nth-child(3) { animation-delay: .4s; }
        @keyframes msDots { 0%, 100% { transform: translateY(0); opacity: .5; } 50% { transform: translateY(-2px); opacity: 1; } }

        /* æ€è€ƒè¿‡ç¨‹ï¼šåˆ‡æ¢æŒ‰é’® + å±•ç¤ºåŒºåŸŸ */
        .ms-think-toggle {
            appearance: none;
            border: 1px solid var(--border);
            background: var(--panel);
            color: color-mix(in oklab, var(--text) 60%, transparent);
            border-radius: var(--radius-xs);
            padding: 2px 6px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
        }
        .ms-think-toggle:hover { background: var(--muted); color: var(--text); }
        .ms-think-toggle:focus-visible { outline: none; box-shadow: var(--focus-ring); }

        .message-thinking { margin: 2px 0 6px; font-size: 0.85em; color: color-mix(in oklab, var(--text) 70%, transparent); white-space: pre-wrap; word-break: break-word; }
        .message-thinking.hidden { display: none; }

        /* æ€è€ƒä¸­çŠ¶æ€ï¼šé—ªçƒçš„å°åœ†ç‚¹å›¾æ ‡ */
        .message-status .think-blink { width: 8px; height: 8px; border-radius: 50%; background: currentColor; display: inline-block; animation: thinkBlink 1s infinite ease-in-out; }
        @keyframes thinkBlink { 0%, 100% { opacity: .3; } 50% { opacity: 1; } }

        /* æ›´è½»é‡çš„æµå¼åŠ è½½å¤–è§‚ */
        .message.streaming { margin-bottom: 10px; }
        .message.streaming .message-header { display: none; }
        .message.streaming .message-avatar { width: 28px; height: 28px; font-size: 12px; }
        .message.streaming .message-text { background: transparent; box-shadow: none; padding: 2px 0; }

        .message.user .message-text {
            background: #667eea;
            color: white;
        }

        /* åŒä¸€æ¡æ¶ˆæ¯å†…çš„åˆ†ç»„æ°”æ³¡å®¹å™¨ */
        .message-bubbles { display: flex; flex-direction: column; gap: 6px; }

        .chat-input {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            align-items: end;
            gap: 10px;
        }

        .chat-input textarea {
            flex: 1;
            padding: 12px;
            border: 1px solid #d0d0d0;
            border-radius: var(--radius-sm);
            font-size: 14px;
            resize: none;
            font-family: inherit;
        }

        /* ç½®åº•æ‚¬æµ®æŒ‰é’® */
        .scroll-bottom-btn {
            position: absolute;
            right: 16px;
            bottom: calc(72px + 12px);
            z-index: 15;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: var(--panel);
            color: var(--text);
            box-shadow: var(--shadow-md);
            opacity: 0;
            transform: translateY(6px);
            pointer-events: none;
            transition: opacity var(--transition), transform var(--transition);
        }
        .scroll-bottom-btn.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        @media (max-width: 768px) {
            .scroll-bottom-btn { right: 10px; bottom: calc(60px + 10px); }
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: var(--radius);
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            overflow-y: auto;
            margin: auto;
        }

        .modal-header h3 {
            color: #333;
            font-size: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 14px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d0d0d0;
            border-radius: var(--radius-xs);
            font-size: 14px;
            font-family: inherit;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-group.checkbox-inline label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 0;
        }

        .form-group.checkbox-inline input[type="checkbox"] {
            width: auto;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .typing-indicator {
            display: inline-block;
        }

        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        .agent-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            vertical-align: middle;
            margin-right: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 40px 0px;
            color: #999;
        }

        .checkbox-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #d0d0d0;
            border-radius: var(--radius-xs);
            padding: 10px;
        }

        .checkbox-item {
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input {
            width: auto;
        }

        .section-divider {
            height: 1px;
            background: #e0e0e0;
            margin: 20px 0;
        }

        .config-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        .config-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .config-section {
            padding: 15px;
            background: #f9fafb;
            border-radius: var(--radius-xs);
            border: 1px solid #e0e0e0;
        }

        .config-section.hidden {
            display: none;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sidebar, .sidebar-right {
            transition: all 0.3s ease;
        }

        .sidebar.hidden {
            width: 0;
            padding: 0;
            border: none;
            overflow: hidden;
            box-shadow: none;
            
/* ä¿ç•™ gapï¼Œä½¿ç”¨è´Ÿ margin æ¥â€œåƒæ‰â€ gap
è¿™ä¸ªæ–¹æ¡ˆæ¯”è¾ƒâ€œå–å·§â€ï¼Œä½†ä¹Ÿèƒ½ç”¨ï¼Œå¹¶ä¸”æ”¹åŠ¨è¾ƒå°ã€‚å®ƒåˆ©ç”¨äº†è´Ÿ margin å¯ä»¥â€œæ‹‰å›â€åç»­å…ƒç´ çš„ç‰¹æ€§æ¥æŠµæ¶ˆ gapã€‚

ä¿ç•™ .container ä¸Šçš„ gap: 16px;

ä¿®æ”¹æ‚¨çš„â€œéšè—â€çŠ¶æ€ï¼š */

/* å…³é”®: æ·»åŠ ä¸€ä¸ªä¸ gap ç­‰å€¼çš„è´Ÿ margin æ¥â€œåƒæ‰â€å®ƒ */

/* è¿™ä¸ªæ–¹æ¡ˆæœ‰é£é™©!!!!!! */

/* å®ƒåœ¨ gap å’Œ margin ä¹‹é—´åˆ›å»ºäº†è€¦åˆã€‚
å¦‚æœå°†æ¥æ‚¨å†³å®šå°† gap ä» 16px æ”¹ä¸º 24pxï¼Œ
å¿…é¡»è®°å¾—åŒæ—¶ä¿®æ”¹éšè—ç±»ä¸­çš„ margin-right: -24pxï¼Œ
å¦åˆ™å¸ƒå±€ä¼šå‡ºé”™ã€‚ */
            margin-right: -16px;
        }

        .sidebar-right.hidden {
            width: 0;
            padding: 0;
            border: none;
            overflow: hidden;
            box-shadow: none;
            margin-left: -16px;
        }

        .sidebar-toggle {
            background: white;
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            border-radius: var(--radius-xs);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .sidebar-toggle:hover {
            background: #f5f5f5;
        }

        @media (max-width: 1200px) {
            .container {
                gap: 10px;
                padding: 10px;
            }

            .sidebar {
                padding: 10px;
                width: 25vw;
                max-width: 280px;
            }

            .sidebar-right {
                padding: 10px;
                width: 28vw;
                max-width: 300px;
            }

            .sidebar.hidden {
                margin-right: -10px;
            }

            .sidebar-right.hidden {
                margin-left: -10px;
            }

            .chat-header {
                padding: 12px 14px;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                gap: 0;
                padding: 0;
            }

            .sidebar, .sidebar-right {
                position: fixed;
                height: calc(100dvh);
                border-radius: 0;
                z-index: 1000;
                transition: all 0.3s ease;
                width: 280px;
            }

            .sidebar {
                left: 0;
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            }

            .sidebar.hidden {
                width: 280px;
                padding: 20px;
                border: none;
                transform: translateX(-100%);
            }

            .sidebar-right {
                right: 0;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }

            .sidebar-right.hidden {
                width: 280px;
                padding: 20px;
                border: none;
                transform: translateX(100%);
            }

            .main-content {
                flex: 1;
                border-radius: 0;
                margin: 0;
            }

            .sidebar-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 8px 12px;
            }

            .chat-header {
                flex-direction: row;
                align-items: center;
                gap: 8px;
                padding: 12px 14px;
                flex-wrap: nowrap;
            }

            .chat-header-left {
                flex: 1 1 auto;
                min-width: 0;
            }

            .chat-header-info h2 {
                font-size: 18px;
            }

            .chat-header-subtitle {
                font-size: 11px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 14px;
            }

            .chat-input {
                flex-direction: row;
                padding: 10px;
                gap: 5px;
            }

            .chat-input textarea {
                font-size: 14px;
                padding: 8px;
                max-height: 80px;
            }

            .modal-content {
                width: 95%;
                max-width: 500px;
                padding: 20px;
                max-height: 90vh;
            }

            .form-group input,
            .form-group textarea,
            .form-group select {
                font-size: 16px;
            }

            .welcome-logo { font-size: 92px; }
        }

        @media (max-width: 480px) {
            .container {
                padding: 0;
            }

            .sidebar, .sidebar-right {
                width: 75vw;
                height: calc(100dvh);
            }

            .chat-header {
                padding: 12px;
                gap: 10px;
                flex-wrap: nowrap;
            }

            .chat-messages {
                padding: 10px;
            }

            .message {
                margin-bottom: 12px;
                gap: 8px;
            }

            .message-avatar {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }

            .message-name {
                font-size: 14px;
            }

            .message-text {
                padding: 8px;
                font-size: 14px;
            }

            .sidebar-toggle {
                padding: 6px 8px;
                font-size: 16px;
                margin-right: 0;
            }

            .btn {
                padding: 6px 10px;
                font-size: 16px;
            }

            .chat-header-info h2 {
                font-size: 16px;
            }

            .chat-header-subtitle {
                display: none;
            }

            .welcome-logo { font-size: 86px; }
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .toast {
            background: white;
            padding: 10px 20px;
            border-radius: var(--radius-sm);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease-out;
            min-width: 300px;
        }

        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }

        .toast.info {
            border-left: 4px solid #3b82f6;
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        .toast-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #999;
            padding: 0;
            flex-shrink: 0;
        }

        .toast-close:hover {
            color: #333;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .toast.removing {
            animation: slideOut 0.3s ease-out forwards;
        }

        @media (max-width: 768px) {
            .toast-container {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .toast {
                min-width: unset;
            }
        }
        
        /* ===== Modern UI: Design Tokens ===== */
        :root {
            --app-bg: hsl(220 14% 97%);
            --panel: hsl(0 0% 100%);
            --text: hsl(224 71% 4%);
            --muted: hsl(220 14% 96%);
            --border: hsl(220 13% 91%);
            --table-bg: hsl(220 14% 95%);

            --brand: hsl(246 83% 60%);
            --brand-contrast: hsl(0 0% 100%);
            --success: hsl(160 84% 39%);
            --warning: hsl(36 100% 45%);
            --error: hsl(0 84% 60%);

            --radius: 12px;
            --radius-lg: 14px;
            --radius-sm: 8px;
            --radius-xs: 6px;
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-md: 0 6px 16px rgba(0,0,0,0.08);
            --shadow-lg: 0 12px 32px rgba(0,0,0,0.12);
            --transition: 200ms cubic-bezier(.2,.7,.2,1);
            --focus-ring: 0 0 0 3px color-mix(in oklab, var(--brand) 35%, transparent);
            --control-bg: hsl(0 0% 100%);

            --bubble-bg-ai: var(--panel);
            --bubble-bg-user: color-mix(in oklab, var(--brand) 18%, var(--panel));
            --bubble-fg-user: var(--text);

            /* Soft danger tokens for subtle destructive actions */
            --danger-soft-bg: hsl(0 100% 97%);
            --danger-soft-bg-hover: hsl(0 100% 95%);
            --danger-soft-bg-active: hsl(0 100% 93%);
            --danger-soft-border: hsl(0 92% 88%);
            --danger-soft-fg: hsl(0 70% 30%);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --app-bg: hsl(224 14% 10%);
                --panel: hsl(224 14% 12%);
                --text: hsl(0 0% 98%);
                --muted: hsl(224 14% 16%);
                --border: hsl(224 14% 22%);
                --table-bg: hsl(224 14% 3%);
                --control-bg: hsl(224 14% 16%);

                --shadow-sm: 0 2px 8px rgba(0,0,0,0.5);
                --shadow-md: 0 6px 16px rgba(0,0,0,0.55);
                --shadow-lg: 0 12px 32px rgba(0,0,0,0.6);

                --bubble-bg-ai: hsl(224 14% 16%);
                --bubble-bg-user: color-mix(in oklab, var(--brand) 26%, var(--panel));
                --bubble-fg-user: var(--text);

                /* Dark theme soft danger */
                --danger-soft-bg: hsl(0 60% 20%);
                --danger-soft-bg-hover: hsl(0 60% 24%);
                --danger-soft-bg-active: hsl(0 60% 18%);
                --danger-soft-border: hsl(0 60% 28%);
                --danger-soft-fg: hsl(0 85% 90%);
            }
        }

        /* ===== Modern UI: Overrides (non-destructive) ===== */
        body { background: var(--app-bg); color: var(--text); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        /* .container { max-width: 1600px; gap: 16px; } */
        .sidebar, .sidebar-right { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius-lg); box-shadow: var(--shadow-md); }
        .sidebar-right-header { display: flex; justify-content: space-between; align-items: center; margin: 3px 0 16px 0; }
        .sidebar-left-header { display: flex; justify-content: space-between; align-items: center; margin: 3px 0 16px 0; }
        .sidebar-right-actions { display: flex; align-items: center; gap: 8px; }
        .main-content { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); }

        .user-bar { background: var(--muted); border: 1px solid var(--border); border-radius: 10px; }
        .item { background: var(--muted); border: 1px solid var(--border); border-radius: 10px; transition: background var(--transition), border-color var(--transition), transform var(--transition); }
        .item:hover { background: color-mix(in oklab, var(--muted) 70%, var(--panel)); }
        .item.active { border-color: var(--brand); background: color-mix(in oklab, var(--brand) 8%, var(--muted)); }

        .btn { height: 36px; padding: 0 14px; border-radius: 10px; font-size: 14px; font-weight: 600; border: 1px solid transparent; transition: background var(--transition), color var(--transition), border-color var(--transition), box-shadow var(--transition); }
        .btn:focus-visible { outline: none; box-shadow: var(--focus-ring); }
        .btn-primary { background: var(--brand); color: var(--brand-contrast); border-color: var(--brand); }
        .btn-primary:hover { filter: brightness(0.95); }
        .btn-secondary { background: var(--panel); color: var(--text); border-color: var(--border); }
        .btn-secondary:hover { background: var(--muted); }
        .btn-danger { background: var(--error); color: #fff; border-color: var(--error); }
        .btn-danger:hover { filter: brightness(0.95); }
        .btn-success { background: var(--success); color: #fff; border-color: var(--success); }
        .btn-success:hover { filter: brightness(0.95); }

        .chat-header { position: sticky; top: 0; backdrop-filter: saturate(150%) blur(8px); background: color-mix(in oklab, var(--panel) 92%, transparent); border-bottom: 1px solid var(--border); z-index: 10; }
        .chat-header-subtitle { color: color-mix(in oklab, var(--text) 60%, transparent); }

        .chat-messages { background: var(--muted); }
        .message-text { background: var(--bubble-bg-ai); color: var(--text); border: 1px solid var(--border); border-radius: var(--radius-lg); box-shadow: var(--shadow-sm); line-height: 1.6; }
        .message.user .message-text { background: var(--bubble-bg-user); color: var(--bubble-fg-user); border-color: color-mix(in oklab, var(--brand) 35%, var(--border)); }
        .message-bubbles { gap: 8px; }
        .message-avatar { box-shadow: var(--shadow-sm); border: 1px solid var(--border); cursor: pointer; }

        .chat-input { position: sticky; bottom: 0; background: var(--panel); border-top: 1px solid var(--border); backdrop-filter: blur(6px); z-index: 10; padding: 14px 16px; }
        .chat-input textarea { background: var(--control-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px 14px; color: var(--text); caret-color: var(--text); color-scheme: light dark; }
        .chat-input textarea::placeholder { color: color-mix(in oklab, var(--text) 55%, transparent); }
        .chat-input textarea:disabled { background: color-mix(in oklab, var(--control-bg) 85%, transparent); color: color-mix(in oklab, var(--text) 60%, transparent); border-color: var(--border); cursor: not-allowed; }
        .chat-input textarea:disabled::placeholder { color: color-mix(in oklab, var(--text) 45%, transparent); }
        .chat-input textarea:focus-visible { outline: none; box-shadow: var(--focus-ring); border-color: var(--brand); }
        .sidebar-toggle { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; }
        .sidebar-toggle:hover { background: var(--muted); }
        .sidebar-toggle:focus-visible { outline: none; box-shadow: var(--focus-ring); }

        .form-group input, .form-group textarea, .form-group select { background: var(--control-bg); border: 1px solid var(--border); color: var(--text); border-radius: 10px; }
        .form-group input:focus-visible, .form-group textarea:focus-visible, .form-group select:focus-visible { outline: none; box-shadow: var(--focus-ring); border-color: var(--brand); }
        .checkbox-list { border-color: var(--border); background: var(--panel); }
        .config-section { background: var(--muted); border-color: var(--border); }

        .toast { background: var(--panel); color: var(--text); border: 1px solid var(--border); box-shadow: var(--shadow-md); }
        .toast-content { color: var(--text); }
        .toast-close { color: color-mix(in oklab, var(--text) 50%, transparent); }
        .toast-close:hover { color: var(--text); }

        /* .message-text pre, .message-text code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
        .message-text pre {  border: 1px solid var(--border); border-radius: 10px; padding: 10px; overflow: auto; }
        .message-text code {  padding: 0 4px; border-radius: 6px; } */

        /* Ensure Vditor preview inherits bubble style */
        .message-text .vditor-reset { color: var(--text); white-space: normal; word-break: normal; }
        .message-text .vditor-reset p,
        .message-text .vditor-reset ul,
        .message-text .vditor-reset ol { margin-bottom: 0.25em; }
        .message-text .vditor-reset ul,
        .message-text .vditor-reset ol { padding-left: 1.15em; }
        /* Compact, harmonious headings inside bubbles */
        .message-text .vditor-reset h1,
        .message-text .vditor-reset h2,
        .message-text .vditor-reset h3,
        .message-text .vditor-reset h4,
        .message-text .vditor-reset h5,
        .message-text .vditor-reset h6 { 
            margin: 0.4em 0 0.3em; 
            line-height: 1.3; 
            font-weight: 700; 
            word-break: break-word; 
            overflow-wrap: anywhere;
        }
        .message-text .vditor-reset h1 { font-size: 1.25em; }
        .message-text .vditor-reset h2 { font-size: 1.15em; }
        .message-text .vditor-reset h3 { font-size: 1.06em; }
        .message-text .vditor-reset h4 { font-size: 1.00em; }
        .message-text .vditor-reset h5 { font-size: 0.95em; }
        .message-text .vditor-reset h6 { font-size: 0.90em; letter-spacing: .02em; }
        .message-text .vditor-reset > :first-child { margin-top: 0; }
        .message-text .vditor-reset > :last-child { margin-bottom: 0; }

        /* .message-text .vditor-reset pre { border: 1px solid var(--border); border-radius: 10px; padding: 10px; } */
        /* .message-text .vditor-reset pre { margin: 0; max-width: 100%; overflow: auto;} */
        .message-text .vditor-reset code { max-height: 100% !important;}
        /* é€‰æ‹© SVG å†…çš„ text å’Œ line */
        .message-text .vditor-reset svg text { fill: var(--text) !important; }
        .message-text .vditor-reset svg line,
        .message-text .vditor-reset svg path,
        .message-text .vditor-reset svg rect,
        .message-text .vditor-reset svg circle,
        .message-text .vditor-reset svg polygon,
        .message-text .vditor-reset svg ellipse,
        .message-text .vditor-reset svg polyline { stroke: var(--text) !important; }

        /* æŠ˜çº¿å›¾èƒŒæ™¯ */
        .message-text .vditor-reset svg g.main rect.background { fill: var(--muted); }

        /* ABC è¯­è¨€æ ·å¼ä¿æŒåŸæ · wheat*/
        .message-text .vditor-reset .language-abc { background: wheat; }
        .message-text .vditor-reset .language-abc svg text { fill: initial !important; }
        .message-text .vditor-reset .language-abc svg path,
        .message-text .vditor-reset .language-abc svg rect {
            /* * "initial" å…³é”®å­—å°†æ ·å¼é‡ç½®ä¸ºæµè§ˆå™¨çš„é»˜è®¤å€¼ã€‚
            * æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ "unset"ï¼ˆæ¢å¤ç»§æ‰¿ï¼‰æˆ–ç‰¹å®šçš„é¢œè‰²ï¼ˆå¦‚ 'black'ï¼‰ã€‚
            * å› ä¸ºåŸå§‹è§„åˆ™æœ‰ !importantï¼Œè¿™é‡Œä¹Ÿå¿…é¡»æœ‰ !important æ‰èƒ½è¦†ç›–å®ƒã€‚
            */
            stroke: initial !important;
        }

        /* è¡¨æ ¼æ ·å¼ */
        .message-text .vditor-reset thead tr { background: color-mix(in oklab, var(--table-bg) 90%, transparent); }
        .message-text .vditor-reset tbody tr { background: color-mix(in oklab, var(--table-bg) 15%, transparent); }
        .message-text .vditor-reset tbody tr:nth-child(2n) { background: color-mix(in oklab, var(--table-bg) 45%, transparent); }

        @media (prefers-reduced-motion: reduce) { * { animation: none !important; transition: none !important; } }

        /* ===== Manual theme override (data-theme) + contrast fixes ===== */
        :root[data-theme="light"] {
            --app-bg: hsl(220 14% 97%);
            --panel: hsl(0 0% 100%);
            --text: hsl(224 71% 4%);
            --muted: hsl(220 14% 96%);
            --border: hsl(220 13% 91%);
            --table-bg: hsl(220 14% 95%);
            --control-bg: hsl(0 0% 100%);
            --bubble-bg-ai: var(--panel);
            --bubble-bg-user: color-mix(in oklab, var(--brand) 18%, var(--panel));
            --bubble-fg-user: var(--text);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-md: 0 6px 16px rgba(0,0,0,0.08);
            --shadow-lg: 0 12px 32px rgba(0,0,0,0.12);

            /* Soft danger tokens for subtle destructive actions */
            --danger-soft-bg: hsl(0 100% 97%);
            --danger-soft-bg-hover: hsl(0 100% 95%);
            --danger-soft-bg-active: hsl(0 100% 93%);
            --danger-soft-border: hsl(0 92% 88%);
            --danger-soft-fg: hsl(0 70% 30%);
        }
        :root[data-theme="dark"] {
            --app-bg: hsl(224 14% 10%);
            --panel: hsl(224 14% 12%);
            --text: hsl(0 0% 98%);
            --muted: hsl(224 14% 16%);
            --border: hsl(224 14% 22%);
            --table-bg: hsl(224 14% 3%);
            --control-bg: hsl(224 14% 16%);
            --bubble-bg-ai: hsl(224 14% 16%);
            --bubble-bg-user: color-mix(in oklab, var(--brand) 26%, var(--panel));
            --bubble-fg-user: var(--text);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.5);
            --shadow-md: 0 6px 16px rgba(0,0,0,0.55);
            --shadow-lg: 0 12px 32px rgba(0,0,0,0.6);

            /* Dark theme soft danger */
            --danger-soft-bg: hsl(0 60% 20%);
            --danger-soft-bg-hover: hsl(0 60% 24%);
            --danger-soft-bg-active: hsl(0 60% 18%);
            --danger-soft-border: hsl(0 60% 28%);
            --danger-soft-fg: hsl(0 85% 90%);
        }

        /* Contrast-safe text and surfaces */
        h2, h3, .user-info, .item-name, .message-name { color: var(--text); }
        .chat-header-info h2 { color: var(--text); }
        .modal-header h3 { color: var(--text); }
        .form-group label { color: color-mix(in oklab, var(--text) 75%, transparent); }
        .item-desc, .empty-state { color: color-mix(in oklab, var(--text) 60%, transparent); }
        .message-time, .toast-close { color: color-mix(in oklab, var(--text) 50%, transparent); }
        .modal-content { background: var(--panel); border: 1px solid var(--border); }
        .section-divider { background: var(--border); }
        .typing-indicator span { background: color-mix(in oklab, var(--text) 50%, transparent); }

        .chat-header-left .sidebar-toggle {
            background: var(--panel);
            color: var(--text);
            border-color: var(--border);
        }
        .chat-header-left .sidebar-toggle:hover { background: var(--muted); }

        /* ===== Modal sticky header/footer overrides ===== */
        .modal-content {
            display: flex;
            flex-direction: column;
            max-height: 85dvh;
            overflow: auto;
            padding: 0;
        }
        .modal-header {
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            margin: 0;
            padding: 12px 20px;
        }
        .modal-header h3 {
            margin: 0;
        }
        .modal-content form {
            flex: 1;
            overflow: auto;
            padding: 0 20px;
            margin-top: 8px;
        }
        .modal-actions {
            position: sticky;
            bottom: 0;
            z-index: 2;
            background: var(--panel);
            border-top: 1px solid var(--border);
            margin: 0;
            padding: 12px 20px;
        }
        @media (max-width: 768px) {
            .modal-content {
                max-height: 75vh;
                padding: 0;
            }
        }

        .chat-header-menu {
            font-size: 16px;
        }

        /* mention menu */
        .mention-menu { position: absolute; background: var(--panel); border: 1px solid var(--border); border-radius: 10px; box-shadow: var(--shadow-md); max-height: 220px; overflow-y: auto; min-width: 220px; display: none; z-index: 20; }
        .mention-item { padding: 8px 10px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .mention-item:hover, .mention-item.active { background: var(--muted); }
        .mention-name { font-weight: 600; }
        .mention-role { font-size: 12px; color: color-mix(in oklab, var(--text) 55%, transparent); }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer"></div>
    <div class="container">
        <div class="sidebar">
            <h1 class="sidebar-left-header">
                <span>Aithos</span>
                <button class="sidebar-toggle btn btn-secondary" id="collapseLeftSidebarBtn" aria-label="æ”¶èµ·å·¦ä¾§æ ">âŸ¨</button>
            </h1>
            <!-- <h2>ç¾¤èŠåˆ—è¡¨</h2> -->
            <div class="list-container" id="groupList"></div>
            <div class="user-bar">
                <div class="user-info">
                    ğŸ‘¤ <span id="userNameDisplay">ç”¨æˆ·</span>
                </div>
                <button class="btn btn-secondary" id="userSettingsBtn">è®¾ç½®</button>
            </div>

            <button class="btn btn-primary" id="createGroupBtn">åˆ›å»ºç¾¤èŠ</button>
        </div>

        <div class="main-content">
            <div class="chat-header">
                <div class="chat-header-left">
                    <button class="sidebar-toggle" id="toggleSidebarBtn">â˜°</button>
                    <div class="chat-header-info">
                        <h2 id="currentGroupName">é€‰æ‹©ä¸€ä¸ªç¾¤èŠ</h2>
                        <div id="groupAgents" class="chat-header-subtitle"></div>
                    </div>
                </div>
                <button class="sidebar-toggle chat-header-menu" id="toggleRightSidebarBtn" aria-label="æ‰“å¼€å³ä¾§æ ">ğŸ‘¥</button>
            </div>
            <div class="chat-messages" id="chatMessages">
                <div class="empty-state">
                    <p>ğŸ‘ˆ ä»å·¦ä¾§é€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªç¾¤èŠ</p>
                </div>
            </div>
            <div class="chat-input">
                <textarea id="userInput" placeholder="è¾“å…¥æ¶ˆæ¯... (Shift+Enteræ¢è¡Œ, Enterå‘é€)" rows="2" disabled></textarea>
                <button class="btn btn-success" id="sendBtn" disabled>å‘é€</button>
                <div id="mentionMenu" class="mention-menu"></div>
            </div>
            <button id="scrollToBottomBtn" class="scroll-bottom-btn" aria-label="ç½®åº•" title="ç½®åº•">â¬‡ï¸ ç½®åº•</button>
        </div>

        <div class="sidebar-right">
            <h2 class="sidebar-right-header">
                <span>AI è§’è‰²</span>
                <div class="sidebar-right-actions">
                    <button class="btn btn-secondary" id="editGroupBtn" aria-label="ç¼–è¾‘ç¾¤èŠ" disabled>ç¼–è¾‘ç¾¤èŠ</button>
                    <button class="sidebar-toggle btn btn-secondary" id="collapseRightSidebarBtn" aria-label="æ”¶èµ·å³ä¾§æ ">âŸ©</button>
                </div>
            </h2>
            <div class="list-container" id="agentList"></div>
            <button class="btn btn-primary" id="createAgentBtn">åˆ›å»ºè§’è‰²</button>
            <button class="btn btn-danger" style="margin-top: 8px;" id="clearChatBtn" aria-label="æ¸…ç©ºå¯¹è¯" disabled>æ¸…ç©ºå¯¹è¯</button>
        </div>
    </div>

    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- ç”¨æˆ·è®¾ç½®æ¨¡æ€æ¡† -->
    <div class="modal" id="userSettingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ç”¨æˆ·è®¾ç½®</h3>
            </div>
            <form id="userSettingsForm">
                <div class="form-group">
                    <label>ç”¨æˆ·æ˜µç§° *</label>
                    <input type="text" id="userNickname" required placeholder="è¾“å…¥ä½ çš„æ˜µç§°">
                </div>
                
                <div class="section-divider"></div>
                <h3>å…¨å±€ API é…ç½®</h3>

                <div class="form-group">
                    <label>Base URL *</label>
                    <input type="text" id="globalBaseUrl" placeholder="https://api.openai.com/v1" required>
                </div>
                <div class="form-group">
                    <label>API Key *</label>
                    <input type="password" id="globalApiKey" required>
                </div>
                <div class="form-group">
                    <label>æ¨¡å‹</label>
                    <div style="display: flex; gap: 10px;">
                        <select id="globalModel" style="flex: 1;">
                            <option value="">-- é€‰æ‹©æ¨¡å‹æˆ–ç‚¹å‡»åˆ·æ–° --</option>
                            <option value="gpt-4-turbo">gpt-4-turbo</option>
                            <option value="gpt-4">gpt-4</option>
                            <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                            <option value="gpt-3.5-turbo-16k">gpt-3.5-turbo-16k</option>
                            <option value="claude-3-opus">claude-3-opus</option>
                            <option value="claude-3-sonnet">claude-3-sonnet</option>
                            <option value="claude-3-haiku">claude-3-haiku</option>
                        </select>
                        <button type="button" class="btn btn-secondary" id="refreshModelsBtn">åˆ·æ–°</button>
                    </div>
                </div>

                <div class="section-divider"></div>
                <h3>TTS è¯­éŸ³æœ—è¯»ï¼ˆå…¨å±€ï¼‰</h3>
                <div class="form-group">
                    <label>TTS Base URL *</label>
                    <input type="text" id="globalTTSBaseUrl" placeholder="https://your-domain.com" required>
                </div>
                <div class="form-group">
                    <label>TTS API Key *</label>
                    <input type="password" id="globalTTSApiKey" placeholder="ç”¨äº /tts æ¥å£çš„ api_key å‚æ•°">
                </div>
                <div class="form-group">
                    <label>Voice</label>
                    <div style="display:flex; gap:10px; align-items:center;">
                        <select id="globalTTSVoice" style="flex:1;">
                            <option value="">-- é€‰æ‹© Voice æˆ–ç‚¹å‡»åˆ·æ–° --</option>
                        </select>
                        <button type="button" class="btn btn-secondary" id="refreshVoicesBtn" title="åˆ·æ–°å¯ç”¨è¯­éŸ³">åˆ·æ–°</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Style</label>
                    <select id="globalTTSStyle">
                        <option value="">-- è‡ªåŠ¨éš Voice å˜åŒ– --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Rate (-100~100)</label>
                    <input type="number" id="globalTTSRate" min="-100" max="100" step="1" value="0">
                </div>
                <div class="form-group">
                    <label>Pitch (-100~100)</label>
                    <input type="number" id="globalTTSPitch" min="-100" max="100" step="1" value="0">
                </div>
                <div class="form-group">
                    <label>æ ¼å¼ (output)</label>
                    <input type="text" id="globalTTSFormat" placeholder="audio-24khz-48kbitrate-mono-mp3">
                </div>

                <div class="section-divider"></div>
                <h3>ç³»ç»Ÿæç¤ºæ˜¾ç¤º</h3>
                <div class="form-group">
                    <label>ç³»ç»Ÿæç¤ºæ˜¾ç¤ºçº§åˆ«</label>
                    <select id="systemMsgLevel">
                        <option value="all">å…¨éƒ¨</option>
                        <option value="info">ä¿¡æ¯ (info)</option>
                        <option value="success">æˆåŠŸ (success)</option>
                        <option value="warning">è­¦å‘Š (warning)</option>
                        <option value="error">é”™è¯¯ (error)</option>
                    </select>
                </div>

                <div class="section-divider"></div>
                <h3>å¤–è§‚</h3>
                <div class="form-group">
                    <label>ä¸»é¢˜æ¨¡å¼</label>
                    <select id="themeMode">
                        <option value="system">è·Ÿéšç³»ç»Ÿ</option>
                        <option value="light">æµ…è‰²</option>
                        <option value="dark">æ·±è‰²</option>
                    </select>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" id="cancelUserSettingsBtn">å–æ¶ˆ</button>
                    <button type="submit" class="btn btn-primary">ä¿å­˜</button>
                </div>
            </form>
        </div>
    </div>

    <!-- è§’è‰²æ¨¡æ€æ¡† -->
    <div class="modal" id="agentModal">
        <div class="modal-content">
            <div class="modal-header">
                    <h3 id="agentModalTitle">åˆ›å»ºè§’è‰²</h3>
            </div>
            <form id="agentForm">
                <div class="form-group">
                    <label>è§’è‰²åç§° *</label>
                    <input type="text" id="agentName" required>
                </div>
                <div class="form-group">
                    <label>è§’è‰²å®šä½</label>
                    <input type="text" id="agentRole" placeholder="ä¾‹å¦‚ï¼šåŠ©æ‰‹ã€ä¸“å®¶ã€é¡¾é—®">
                </div>
                <div class="form-group">
                    <label>ç³»ç»Ÿæç¤ºè¯ *</label>
                    <textarea id="agentPrompt" required placeholder="æè¿°è¿™ä¸ªè§’è‰²çš„æ€§æ ¼ã€ä¸“é•¿å’Œè¡Œä¸ºæ–¹å¼"></textarea>
                </div>
                <div class="form-group">
                    <label>å¤´åƒé¢œè‰²</label>
                    <input type="color" id="agentColor" value="#667eea">
                </div>
                
                <div class="section-divider"></div>
                <h3>API é…ç½®</h3>

                <div class="config-toggle">
                    <input type="checkbox" id="agentUseGlobal" checked>
                    <label for="agentUseGlobal" style="margin-bottom: 0;">ä½¿ç”¨å…¨å±€é…ç½®</label>
                </div>

                <div class="config-section hidden" id="agentConfigSection">
                    <div class="form-group">
                        <label>Base URL *</label>
                        <input type="text" id="agentBaseUrl" placeholder="https://api.openai.com/v1">
                    </div>
                    <div class="form-group">
                        <label>API Key *</label>
                        <input type="password" id="agentApiKey">
                    </div>
                    <div class="form-group">
                        <label>æ¨¡å‹</label>
                        <div style="display:flex; gap:10px;">
                            <select id="agentModel" style="flex:1;">
                                <option value="">-- é€‰æ‹©æ¨¡å‹æˆ–ç‚¹å‡»åˆ·æ–° --</option>
                                <option value="gpt-4-turbo">gpt-4-turbo</option>
                                <option value="gpt-4">gpt-4</option>
                                <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                                <option value="gpt-3.5-turbo-16k">gpt-3.5-turbo-16k</option>
                                <option value="claude-3-opus">claude-3-opus</option>
                                <option value="claude-3-sonnet">claude-3-sonnet</option>
                                <option value="claude-3-haiku">claude-3-haiku</option>
                            </select>
                            <button type="button" class="btn btn-secondary" id="agentRefreshModelsBtn">åˆ·æ–°</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Temperature (0-2)</label>
                        <input type="number" id="agentTemperature" min="0" max="2" step="0.1" value="0.7">
                    </div>
                    <div class="form-group">
                        <label>Max Tokens</label>
                        <input type="number" id="agentMaxTokens" min="1" max="32000" value="2000">
                    </div>
                </div>

                <div class="section-divider"></div>
                <h3>TTS é…ç½®</h3>
                <div class="config-toggle">
                    <input type="checkbox" id="agentTTSUseGlobal" checked>
                    <label for="agentTTSUseGlobal" style="margin-bottom:0;">ä½¿ç”¨å…¨å±€é…ç½®</label>
                </div>
                <div class="config-section hidden" id="agentTTSConfigSection">
                    <div class="form-group">
                        <label>TTS Base URL *</label>
                        <input type="text" id="agentTTSBaseUrl" placeholder="https://your-domain.com">
                    </div>
                    <div class="form-group">
                        <label>TTS API Key *</label>
                        <input type="password" id="agentTTSApiKey" placeholder="ç”¨äº /tts æ¥å£çš„ api_key å‚æ•°">
                    </div>
                    <div class="form-group">
                        <label>Voice</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <select id="agentTTSVoice" style="flex:1;">
                                <option value="">-- é€‰æ‹© Voice æˆ–ç‚¹å‡»åˆ·æ–° --</option>
                            </select>
                            <button type="button" class="btn btn-secondary" id="agentRefreshVoicesBtn">åˆ·æ–°</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Style</label>
                        <select id="agentTTSStyle">
                            <option value="">-- è‡ªåŠ¨éš Voice å˜åŒ– --</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Rate (-100~100)</label>
                        <input type="number" id="agentTTSRate" min="-100" max="100" step="1" value="0">
                    </div>
                    <div class="form-group">
                        <label>Pitch (-100~100)</label>
                        <input type="number" id="agentTTSPitch" min="-100" max="100" step="1" value="0">
                    </div>
                    <div class="form-group">
                        <label>æ ¼å¼ (output)</label>
                        <input type="text" id="agentTTSFormat" placeholder="audio-24khz-48kbitrate-mono-mp3">
                    </div>
                </div>

                <div class="section-divider"></div>
                <h3>æƒé™ï¼ˆä»…å½“å‰ç¾¤èŠï¼‰</h3>
                <div class="form-group">
                    <label>æˆ‘èƒ½çœ‹è§è°</label>
                    <div class="config-toggle" style="display:flex; gap:12px; align-items:center;">
                        <label for="permSeeMode_all" style="margin:0; display:inline-flex; gap:6px; align-items:center;">
                            <input type="radio" id="permSeeMode_all" name="permSeeMode" value="all" checked> æ‰€æœ‰
                        </label>
                        <label for="permSeeMode_custom" style="margin:0; display:inline-flex; gap:6px; align-items:center;">
                            <input type="radio" id="permSeeMode_custom" name="permSeeMode" value="custom"> è‡ªå®šä¹‰
                        </label>
                    </div>
                    <div class="checkbox-list" id="permICanSeeList" style="display:none;"></div>
                </div>

                <div class="form-group">
                    <label>è°èƒ½çœ‹è§æˆ‘</label>
                    <div class="config-toggle" style="display:flex; gap:12px; align-items:center;">
                        <label for="permSeenMode_all" style="margin:0; display:inline-flex; gap:6px; align-items:center;">
                            <input type="radio" id="permSeenMode_all" name="permSeenMode" value="all" checked> æ‰€æœ‰
                        </label>
                        <label for="permSeenMode_custom" style="margin:0; display:inline-flex; gap:6px; align-items:center;">
                            <input type="radio" id="permSeenMode_custom" name="permSeenMode" value="custom"> è‡ªå®šä¹‰
                        </label>
                    </div>
                    <div class="checkbox-list" id="permCanSeeMeList" style="display:none;"></div>
                </div>

                <div class="form-group">
                    <label>è§†é‡ï¼ˆæ¶ˆæ¯ä¸Šä¸‹æ–‡ï¼‰</label>
                    <select id="permVisionType">
                        <option value="all">æ‰€æœ‰æ¶ˆæ¯</option>
                        <option value="last1">æœ€è¿‘ä¸€æ¡æ¶ˆæ¯</option>
                        <option value="custom">è‡ªå®šä¹‰è§„åˆ™</option>
                    </select>
                </div>
                <div class="form-group" id="permVisionExprWrap" style="display:none;">
                    <label>è‡ªå®šä¹‰è§„åˆ™ï¼ˆç›´æ¥å¡«å†™ç´¢å¼•ä¸èŒƒå›´ï¼Œç¤ºä¾‹ï¼š1,2,8:0 æˆ– -4:-1 æˆ– 9: æˆ– :0 æˆ– 1,3,-2ï¼‰</label>
                    <input type="text" id="permVisionExpr" placeholder="ä¾‹å¦‚ï¼š1,2,8:0 æˆ– -4:-1">
                    <div id="permVisionError" style="display:none; color:#b91c1c; font-size:12px; margin-top:6px;"></div>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" id="cancelAgentModalBtn">å–æ¶ˆ</button>
                    <button type="submit" class="btn btn-primary">ä¿å­˜</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ç¾¤èŠæ¨¡æ€æ¡† -->
    <div class="modal" id="groupModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="groupModalTitle">åˆ›å»ºç¾¤èŠ</h3>
            </div>
            <form id="groupForm">
                <div class="form-group">
                    <label>ç¾¤èŠåç§° *</label>
                    <input type="text" id="groupName" required>
                </div>
                <div class="form-group">
                    <label>ç¾¤èŠæè¿°</label>
                    <textarea id="groupDesc" placeholder="æè¿°è¿™ä¸ªç¾¤èŠçš„ç”¨é€”"></textarea>
                </div>
                <div class="form-group">
                    <label>é€‰æ‹©å‚ä¸çš„ AI è§’è‰² *</label>
                    <div class="checkbox-list" id="agentCheckboxList"></div>
                </div>
                <div class="form-group checkbox-inline">
                    <label for="groupAutoReply">
                        <input type="checkbox" id="groupAutoReply" checked>
                        <span>è‡ªåŠ¨å›å¤</span>
                    </label>
                </div>
                <div class="form-group" id="groupAutoReplyModeWrap">
                    <label>è‡ªåŠ¨å›å¤æ¨¡å¼</label>
                    <select id="groupAutoReplyMode">
                        <option value="round_robin">è½®æµå›ºå®š</option>
                        <option value="random">éšæœº</option>
                        <option value="ai_selector">AI å†³å®šï¼ˆå‚è€ƒä¸Šä¸‹æ–‡ï¼‰</option>
                    </select>
                </div>
                <div class="form-group" id="groupSelectorModelWrap" style="display:none;">
                    <label>é€‰æ‹©å™¨æ¨¡å‹</label>
                    <div style="display:flex; gap:10px;">
                        <select id="groupSelectorModel" style="flex:1;">
                            <option value="">-- é€‰æ‹©æ¨¡å‹æˆ–ç‚¹å‡»åˆ·æ–° --</option>
                        </select>
                        <button type="button" class="btn btn-secondary" id="groupSelectorRefreshModelsBtn">åˆ·æ–°</button>
                    </div>
                </div>
                <div class="form-group" id="groupMaxRoundsWrap">
                    <label>æœ€å¤§è‡ªåŠ¨å›å¤è½®æ•°</label>
                    <input type="number" id="groupMaxRounds" min="1" max="20" value="5">
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" id="cancelGroupModalBtn">å–æ¶ˆ</button>
                    <button type="submit" class="btn btn-primary">ä¿å­˜</button>
                </div>
            </form>
        </div>
    </div>

    

    <script type="module">
        const qs = (s, r=document) => r.querySelector(s);
        const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));

        let OpenAI;
        
        async function loadOpenAI() {
            if (!OpenAI) {
                const module = await import('https://cdn.jsdelivr.net/npm/openai@6.4.0/+esm');
                OpenAI = module.default;
            }
            return OpenAI;
        }

        let agents = [];
        let groups = [];
        let currentGroupId = null;
        let currentEditingAgent = null;
        let currentEditingGroup = null;
        const ALL_AGENTS_GROUP_ID = 'all_agents_group';
        let globalSettings = {
            userName: 'ç”¨æˆ·',
            baseUrl: 'https://api.openai.com/v1',
            apiKey: '',
            model: 'gpt-3.5-turbo',
            models: [],
            systemMsgLevel: 'all',
            themeMode: 'system',
            tts: {
                baseUrl: 'https://your-domain.com',
                apiKey: '',
                voice: 'zh-CN-XiaoxiaoMultilingualNeural',
                style: 'general',
                rate: 0,
                pitch: 0,
                format: 'audio-24khz-48kbitrate-mono-mp3'
            }
        };

        let openaiClients = {};
        const inflight = new Map(); // msgId -> { ac, stream? }

        const el = {
            userSettingsBtn: qs('#userSettingsBtn'),
            cancelUserSettingsBtn: qs('#cancelUserSettingsBtn'),
            userSettingsForm: qs('#userSettingsForm'),
            userNickname: qs('#userNickname'),
            globalBaseUrl: qs('#globalBaseUrl'),
            globalApiKey: qs('#globalApiKey'),
            globalModel: qs('#globalModel'),
            refreshModelsBtn: qs('#refreshModelsBtn'),
            agentRefreshModelsBtn: qs('#agentRefreshModelsBtn'),
            userSettingsModal: qs('#userSettingsModal'),
            systemMsgLevel: qs('#systemMsgLevel'),
            themeMode: qs('#themeMode'),
            // Global TTS
            globalTTSBaseUrl: qs('#globalTTSBaseUrl'),
            globalTTSApiKey: qs('#globalTTSApiKey'),
            globalTTSVoice: qs('#globalTTSVoice'),
            refreshVoicesBtn: qs('#refreshVoicesBtn'),
            globalTTSStyle: qs('#globalTTSStyle'),
            globalTTSRate: qs('#globalTTSRate'),
            globalTTSPitch: qs('#globalTTSPitch'),
            globalTTSFormat: qs('#globalTTSFormat'),
            
            createGroupBtn: qs('#createGroupBtn'),
            cancelGroupModalBtn: qs('#cancelGroupModalBtn'),
            groupForm: qs('#groupForm'),
            groupName: qs('#groupName'),
            groupDesc: qs('#groupDesc'),
            groupAutoReply: qs('#groupAutoReply'),
            groupAutoReplyMode: qs('#groupAutoReplyMode'),
            groupAutoReplyModeWrap: qs('#groupAutoReplyModeWrap'),
            groupSelectorModelWrap: qs('#groupSelectorModelWrap'),
            groupSelectorModel: qs('#groupSelectorModel'),
            groupSelectorRefreshModelsBtn: qs('#groupSelectorRefreshModelsBtn'),
            groupMaxRounds: qs('#groupMaxRounds'),
            groupMaxRoundsWrap: qs('#groupMaxRoundsWrap'),
            agentCheckboxList: qs('#agentCheckboxList'),
            groupModal: qs('#groupModal'),
            groupModalTitle: qs('#groupModalTitle'),
            groupList: qs('#groupList'),
            
            createAgentBtn: qs('#createAgentBtn'),
            cancelAgentModalBtn: qs('#cancelAgentModalBtn'),
            agentForm: qs('#agentForm'),
            agentName: qs('#agentName'),
            agentRole: qs('#agentRole'),
            agentPrompt: qs('#agentPrompt'),
            agentColor: qs('#agentColor'),
            agentUseGlobal: qs('#agentUseGlobal'),
            agentConfigSection: qs('#agentConfigSection'),
            agentBaseUrl: qs('#agentBaseUrl'),
            agentApiKey: qs('#agentApiKey'),
            agentModel: qs('#agentModel'),
            agentTemperature: qs('#agentTemperature'),
            agentMaxTokens: qs('#agentMaxTokens'),
            // Agent TTS
            agentTTSUseGlobal: qs('#agentTTSUseGlobal'),
            agentTTSConfigSection: qs('#agentTTSConfigSection'),
            agentTTSBaseUrl: qs('#agentTTSBaseUrl'),
            agentTTSApiKey: qs('#agentTTSApiKey'),
            agentTTSVoice: qs('#agentTTSVoice'),
            agentRefreshVoicesBtn: qs('#agentRefreshVoicesBtn'),
            agentTTSStyle: qs('#agentTTSStyle'),
            agentTTSRate: qs('#agentTTSRate'),
            agentTTSPitch: qs('#agentTTSPitch'),
            agentTTSFormat: qs('#agentTTSFormat'),
            agentModal: qs('#agentModal'),
            agentModalTitle: qs('#agentModalTitle'),
            agentList: qs('#agentList'),
            permICanSeeList: qs('#permICanSeeList'),
            permCanSeeMeList: qs('#permCanSeeMeList'),
            permVisionType: qs('#permVisionType'),
            permVisionExprWrap: qs('#permVisionExprWrap'),
            permVisionExpr: qs('#permVisionExpr'),
            permVisionError: qs('#permVisionError'),
            
            toggleSidebarBtn: qs('#toggleSidebarBtn'),
            themeToggleBtn: qs('#themeToggleBtn'),
            toggleRightSidebarBtn: qs('#toggleRightSidebarBtn'),
            editGroupBtn: qs('#editGroupBtn'),
            clearChatBtn: qs('#clearChatBtn'),
            currentGroupName: qs('#currentGroupName'),
            groupAgents: qs('#groupAgents'),
            chatMessages: qs('#chatMessages'),
            userInput: qs('#userInput'),
            sendBtn: qs('#sendBtn'),
            mentionMenu: qs('#mentionMenu'),
            toastContainer: qs('#toastContainer'),
            userNameDisplay: qs('#userNameDisplay'),
            sidebarOverlay: qs('#sidebarOverlay'),
            scrollToBottomBtn: qs('#scrollToBottomBtn'),
            collapseLeftSidebarBtn: qs('#collapseLeftSidebarBtn'),
            collapseRightSidebarBtn: qs('#collapseRightSidebarBtn')
        };

        // èŠå¤©è‡ªåŠ¨æ»šåŠ¨ï¼šä»…åœ¨ç”¨æˆ·ä½äºåº•éƒ¨æ—¶ä¿æŒç½®åº•
        let shouldAutoScroll = true;
        const isAtBottom = (node, threshold = 24) => (node.scrollHeight - node.scrollTop - node.clientHeight) <= threshold;

        function scrollToBottom(smooth = true) {
            if (!el.chatMessages) return;
            try {
                el.chatMessages.scrollTo({ top: el.chatMessages.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
            } catch (_) {
                el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
            }
        }

        function showToast(message, type = 'info', duration = 3000, action) {
            const container = el.toastContainer;
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icons = {
                success: 'âœ“',
                error: 'âœ•',
                info: 'â„¹',
                warning: 'âš '
            };

            const hasAction = action && typeof action.onClick === 'function' && action.text;
            const actionHtml = hasAction ? `<button class="btn btn-secondary" data-toast-action="action">${action.text}</button>` : '';

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || 'â„¹'}</span>
                <div class="toast-content">${message}</div>
                ${actionHtml}
                <button class="toast-close" aria-label="å…³é—­" onclick="this.parentElement.remove()">âœ•</button>
            `;

            container.appendChild(toast);

            let timerId = null;
            if (duration > 0) {
                timerId = setTimeout(() => {
                    if (toast.parentElement) {
                        toast.classList.add('removing');
                        setTimeout(() => toast.remove(), 300);
                    }
                }, duration);
            }

            if (hasAction) {
                const btn = toast.querySelector('[data-toast-action="action"]');
                if (btn) {
                    btn.addEventListener('click', () => {
                        try { action.onClick(); } finally {
                            if (timerId) clearTimeout(timerId);
                            if (toast.parentElement) toast.remove();
                        }
                    });
                }
            }
        }

        function init() {
            loadData();
            ensureAllAgentsGroup();
            initTheme();
            renderAgents();
            renderGroups();
            autoEnterLastGroup();
            autoSelectFirstGroupIfNone();
            updateUserDisplay();
            initOpenAI().catch(e => console.error('åˆå§‹åŒ– OpenAI å®¢æˆ·ç«¯å¤±è´¥:', e));
            setupEventListeners();
        }

        function loadData() {
            const savedAgents = localStorage.getItem('agents_v3');
            const savedGroups = localStorage.getItem('groups_v3');
            const savedSettings = localStorage.getItem('globalSettings_v3');

            if (savedAgents) agents = JSON.parse(savedAgents);
            if (savedGroups) groups = JSON.parse(savedGroups);
            if (savedSettings) globalSettings = JSON.parse(savedSettings);
            if (!globalSettings.systemMsgLevel) {
                globalSettings.systemMsgLevel = 'all';
            }
            if (!globalSettings.tts) {
                globalSettings.tts = { baseUrl: 'https://your-domain.com', apiKey: '', voice: 'zh-CN-XiaoxiaoMultilingualNeural', style: 'general', rate: 0, pitch: 0, format: 'audio-24khz-48kbitrate-mono-mp3' };
            } else {
                const t = globalSettings.tts;
                if (t.rate === undefined) t.rate = 0;
                if (t.pitch === undefined) t.pitch = 0;
                if (!t.format) t.format = 'audio-24khz-48kbitrate-mono-mp3';
            }
        }

        function saveData() {
            localStorage.setItem('agents_v3', JSON.stringify(agents));
            localStorage.setItem('groups_v3', JSON.stringify(groups));
            localStorage.setItem('globalSettings_v3', JSON.stringify(globalSettings));
        }

        function ensureAllAgentsGroup() {
            try {
                let allGroup = groups.find(g => g.isAllAgentsGroup === true || g.id === ALL_AGENTS_GROUP_ID);
                const allIds = Array.from(new Set(agents.map(a => a.id)));
                if (!allGroup) {
                    allGroup = {
                        id: ALL_AGENTS_GROUP_ID,
                        name: 'æ‰€æœ‰è§’è‰²',
                        desc: 'åŒ…å«å…¨éƒ¨è§’è‰²',
                        agentIds: allIds,
                        autoReply: false,
                        autoReplyMode: 'round_robin',
                        maxRounds: 5,
                        isAllAgentsGroup: true,
                        messages: []
                    };
                    groups.unshift(allGroup);
                    saveData();
                } else {
                    allGroup.isAllAgentsGroup = true;
                    allGroup.agentIds = allIds;
                    allGroup.autoReply = false; // ç¦æ­¢è‡ªåŠ¨å›å¤
                    saveData();
                }
            } catch (_) {
                // å¿½ç•¥
            }
        }

        // ==== Theme control ====
        function initTheme() {
            // è¿ç§»æ—§çš„ localStorage 'theme'ï¼ˆè‹¥å­˜åœ¨ï¼‰åˆ°å…¨å±€è®¾ç½®
            try {
                const legacy = localStorage.getItem('theme');
                if (!globalSettings.themeMode && legacy) {
                    globalSettings.themeMode = legacy === 'dark' ? 'dark' : 'light';
                    saveData();
                }
            } catch (_) {}

            const mode = globalSettings.themeMode || 'system';
            applyTheme(mode);
        }

        function applyTheme(mode) {
            const root = document.documentElement;
            if (mode === 'system') {
                root.removeAttribute('data-theme');
            } else if (mode === 'light' || mode === 'dark') {
                root.setAttribute('data-theme', mode);
            }
        }

        async function initOpenAI() {
            if (!globalSettings.apiKey) return;
            
            try {
                const OpenAIClass = await loadOpenAI();
                const key = `global_${globalSettings.apiKey.slice(0, 10)}`;
                openaiClients[key] = new OpenAIClass({
                    apiKey: globalSettings.apiKey,
                    baseURL: globalSettings.baseUrl,
                    dangerouslyAllowBrowser: true
                });
            } catch (e) {
                console.error('OpenAI åˆå§‹åŒ–å¤±è´¥:', e);
                showToast('OpenAI åˆå§‹åŒ–å¤±è´¥: ' + e.message, 'error');
            }
        }

        async function getOpenAIClient(config) {
            const key = `${config.apiKey.slice(0, 10)}_${config.baseUrl}`;
            if (!openaiClients[key]) {
                try {
                    const OpenAIClass = await loadOpenAI();
                    openaiClients[key] = new OpenAIClass({
                        apiKey: config.apiKey,
                        baseURL: config.baseUrl,
                        dangerouslyAllowBrowser: true
                    });
                } catch (e) {
                    console.error('OpenAI å®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥:', e);
                    throw e;
                }
            }
            return openaiClients[key];
        }

        async function loadModels(e) {
            if (!globalSettings.apiKey || !globalSettings.baseUrl) {
                showToast('è¯·å…ˆé…ç½® API Key å’Œ Base URL', 'warning');
                return;
            }

            try {
                const btn = e ? e.target : el.refreshModelsBtn;
                btn.disabled = true;
                btn.innerHTML = '<div class="loading-spinner"></div>';

                const client = await getOpenAIClient(globalSettings);
                const response = await client.models.list();

                const models = response.data
                    .map(m => m.id)
                    .sort((a, b) => a.localeCompare(b));
                
                globalSettings.models = models;
                saveData();
                updateModelSelects();
                
                btn.disabled = false;
                btn.textContent = 'åˆ·æ–°';
                showToast(`æˆåŠŸåŠ è½½ ${models.length} ä¸ªæ¨¡å‹`, 'success');
            } catch (error) {
                const btn = e ? e.target : el.refreshModelsBtn;
                btn.disabled = false;
                btn.textContent = 'åˆ·æ–°';
                showToast('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥: ' + error.message, 'error');
            }
        }

        async function loadAgentModels(e) {
            try {
                const btn = e ? e.target : el.agentRefreshModelsBtn;
                if (btn) { btn.disabled = true; btn.innerHTML = '<div class="loading-spinner"></div>'; }

                // æ ¹æ®æ˜¯å¦ä½¿ç”¨å…¨å±€é…ç½®é€‰æ‹©æ¥æºï¼›è‹¥è‡ªå®šä¹‰ä¸ºç©ºåˆ™å›é€€å…¨å±€
                const useGlobal = el.agentUseGlobal?.checked !== false; // æœªæ‰¾åˆ°è§†ä¸ºå…¨å±€
                const baseUrl = useGlobal ? globalSettings.baseUrl : (el.agentBaseUrl?.value || globalSettings.baseUrl);
                const apiKey = useGlobal ? globalSettings.apiKey : (el.agentApiKey?.value || globalSettings.apiKey);
                if (!apiKey || !baseUrl) {
                    if (btn) { btn.disabled = false; btn.textContent = 'åˆ·æ–°'; }
                    showToast('è¯·å…ˆå¡«å†™å¯ç”¨çš„ API Key å’Œ Base URL', 'warning');
                    return;
                }

                const client = await getOpenAIClient({ baseUrl, apiKey });
                const response = await client.models.list();
                const models = response.data.map(m => m.id).sort((a,b)=>a.localeCompare(b));

                if (el.agentModel) {
                    const currentValue = el.agentModel.value;
                    el.agentModel.innerHTML = models.map(m => `<option value="${m}">${m}</option>`).join('');
                    if (currentValue) {
                        el.agentModel.value = currentValue;
                        if (el.agentModel.value !== currentValue) {
                            const opt = document.createElement('option');
                            opt.value = currentValue;
                            opt.textContent = currentValue;
                            el.agentModel.appendChild(opt);
                            el.agentModel.value = currentValue;
                        }
                    }
                }

                if (btn) { btn.disabled = false; btn.textContent = 'åˆ·æ–°'; }
                showToast(`æˆåŠŸåŠ è½½ ${models.length} ä¸ªæ¨¡å‹`, 'success');
            } catch (error) {
                const btn = e ? e.target : el.agentRefreshModelsBtn;
                if (btn) { btn.disabled = false; btn.textContent = 'åˆ·æ–°'; }
                showToast('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥: ' + error.message, 'error');
            }
        }

        function updateModelSelects() {
            const defaultModels = [
                { value: 'gpt-4-turbo', text: 'gpt-4-turbo' },
                { value: 'gpt-4', text: 'gpt-4' },
                { value: 'gpt-3.5-turbo', text: 'gpt-3.5-turbo' },
                { value: 'gpt-3.5-turbo-16k', text: 'gpt-3.5-turbo-16k' },
                { value: 'claude-3-opus', text: 'claude-3-opus' },
                { value: 'claude-3-sonnet', text: 'claude-3-sonnet' },
                { value: 'claude-3-haiku', text: 'claude-3-haiku' }
            ];

            [el.globalModel, el.agentModel].forEach(select => {
                const currentValue = select.value;
                let options = '';
                
                if (globalSettings.models && globalSettings.models.length > 0) {
                    options = globalSettings.models
                        .map(model => `<option value="${model}">${model}</option>`)
                        .join('');
                    const has = Array.from(globalSettings.models).some(o => o.value === globalSettings.model);
                    if (!has) {
                        options += `<option value="${globalSettings.model}">${globalSettings.model}</option>`;
                    }
                } else {
                    options = defaultModels
                        .map(m => `<option value="${m.value}">${m.text}</option>`)
                        .join('');
                }
                
                select.innerHTML = `<option>-- é€‰æ‹©æ¨¡å‹æˆ–ç‚¹å‡»åˆ·æ–° --</option>` + options;
                if (currentValue) {
                    select.value = currentValue;
                    if (select.value !== currentValue) {
                        const opt = document.createElement('option');
                        opt.value = currentValue;
                        opt.textContent = currentValue;
                        select.appendChild(opt);
                        select.value = currentValue;
                    }
                }
            });
        }

        function setupEventListeners() {
            el.userInput.addEventListener('keydown', (e) => {
                if (mentionState.open) {
                    if (e.key === 'ArrowDown') { e.preventDefault(); moveMention(1); return; }
                    if (e.key === 'ArrowUp') { e.preventDefault(); moveMention(-1); return; }
                    if (e.key === 'Tab') { e.preventDefault(); chooseMention(); return; }
                    if (e.key === 'Enter') { e.preventDefault(); chooseMention(); return; }
                    if (e.key === 'Escape') { closeMention(); return; }
                }
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            el.userInput.addEventListener('input', () => {
                updateSendBtnLabel();
                updateMention();
            });

            el.userSettingsBtn.addEventListener('click', openUserSettingsModal);
            el.cancelUserSettingsBtn.addEventListener('click', closeUserSettingsModal);
            el.userSettingsForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveUserSettings();
            });

            // é…ç½®å˜æ›´ï¼šå³æ—¶ç”Ÿæ•ˆï¼ˆæ— éœ€ç‚¹ä¿å­˜ï¼‰
            if (el.systemMsgLevel) {
                el.systemMsgLevel.addEventListener('change', () => {
                    globalSettings.systemMsgLevel = el.systemMsgLevel.value || 'all';
                    saveData();
                    if (currentGroupId) renderMessages();
                });
            }
            if (el.themeMode) {
                el.themeMode.addEventListener('change', () => {
                    globalSettings.themeMode = el.themeMode.value || 'system';
                    saveData();
                    applyTheme(globalSettings.themeMode);
                });
            }
            if (el.globalModel) {
                el.globalModel.addEventListener('change', () => {
                    globalSettings.model = el.globalModel.value || '';
                    saveData();
                    // å³æ ç”¨æˆ·æ¡ç›®å±•ç¤ºå…¨å±€æ¨¡å‹
                    renderAgents();
                });
            }
            if (el.globalBaseUrl) {
                const onBaseUrlChange = async () => {
                    globalSettings.baseUrl = el.globalBaseUrl.value || '';
                    saveData();
                    try { await initOpenAI(); } catch (_) {}
                };
                el.globalBaseUrl.addEventListener('input', onBaseUrlChange);
                el.globalBaseUrl.addEventListener('change', onBaseUrlChange);
            }
            if (el.globalApiKey) {
                const onApiKeyChange = async () => {
                    globalSettings.apiKey = el.globalApiKey.value || '';
                    saveData();
                    try { await initOpenAI(); } catch (_) {}
                };
                el.globalApiKey.addEventListener('input', onApiKeyChange);
                el.globalApiKey.addEventListener('change', onApiKeyChange);
            }

            // Global TTS bindings
            if (el.globalTTSBaseUrl) {
                const on = () => { globalSettings.tts.baseUrl = el.globalTTSBaseUrl.value || ''; saveData(); };
                el.globalTTSBaseUrl.addEventListener('input', on); el.globalTTSBaseUrl.addEventListener('change', on);
            }
            if (el.globalTTSApiKey) {
                const on = () => { globalSettings.tts.apiKey = el.globalTTSApiKey.value || ''; saveData(); };
                el.globalTTSApiKey.addEventListener('input', on); el.globalTTSApiKey.addEventListener('change', on);
            }
            if (el.globalTTSVoice) {
                el.globalTTSVoice.addEventListener('change', () => {
                    globalSettings.tts.voice = el.globalTTSVoice.value || '';
                    // update styles according to selected voice
                    const base = (globalSettings.tts.baseUrl||'').replace(/\/$/,'');
                    const voices = ttsVoicesCache.get(base) || [];
                    fillStyleSelect(el.globalTTSStyle, voices, el.globalTTSVoice.value, globalSettings.tts.style);
                    saveData();
                });
            }
            if (el.globalTTSStyle) {
                el.globalTTSStyle.addEventListener('change', () => {
                    globalSettings.tts.style = el.globalTTSStyle.value || '';
                    saveData();
                });
            }
            if (el.globalTTSRate) {
                el.globalTTSRate.addEventListener('input', () => { globalSettings.tts.rate = parseInt(el.globalTTSRate.value||'0',10)||0; saveData(); });
            }
            if (el.globalTTSPitch) {
                el.globalTTSPitch.addEventListener('input', () => { globalSettings.tts.pitch = parseInt(el.globalTTSPitch.value||'0',10)||0; saveData(); });
            }
            if (el.globalTTSFormat) {
                const on = () => { globalSettings.tts.format = el.globalTTSFormat.value || 'audio-24khz-48kbitrate-mono-mp3'; saveData(); };
                el.globalTTSFormat.addEventListener('input', on); el.globalTTSFormat.addEventListener('change', on);
            }
            if (el.refreshVoicesBtn) {
                el.refreshVoicesBtn.addEventListener('click', async () => {
                    try {
                        const voices = await fetchVoices(globalSettings.tts.baseUrl);
                        const base = (globalSettings.tts.baseUrl||'').replace(/\/$/,'');
                        ttsVoicesCache.set(base, voices);
                        fillVoiceSelect(el.globalTTSVoice, voices, globalSettings.tts.voice);
                        fillStyleSelect(el.globalTTSStyle, voices, el.globalTTSVoice.value, globalSettings.tts.style);
                        showToast('å·²åˆ·æ–° Voices', 'success');
                    } catch (_) { showToast('åˆ·æ–° Voices å¤±è´¥', 'error'); }
                });
            }

            // ç¾¤èŠé…ç½®ä¸­çš„æ•°å€¼ï¼šå³æ—¶ç”Ÿæ•ˆï¼ˆç¼–è¾‘æ¨¡å¼ï¼‰
            if (el.groupMaxRounds) {
                el.groupMaxRounds.addEventListener('input', () => {
                    if (currentEditingGroup !== null) {
                        const v = parseInt(el.groupMaxRounds.value, 10);
                        groups[currentEditingGroup].maxRounds = isNaN(v) ? 0 : v;
                        saveData();
                    }
                });
            }

            // è§’è‰²é…ç½®ä¸­çš„æ•°å€¼ï¼šå³æ—¶ç”Ÿæ•ˆï¼ˆç¼–è¾‘æ¨¡å¼ï¼Œä½¿ç”¨è‡ªå®šä¹‰é…ç½®æ—¶ï¼‰
            if (el.agentTemperature) {
                el.agentTemperature.addEventListener('input', () => {
                    if (currentEditingAgent !== null && agents[currentEditingAgent] && agents[currentEditingAgent].useGlobal === false) {
                        const v = parseFloat(el.agentTemperature.value);
                        agents[currentEditingAgent].temperature = isNaN(v) ? 0.7 : v;
                        saveData();
                    }
                });
            }
            if (el.agentMaxTokens) {
                el.agentMaxTokens.addEventListener('input', () => {
                    if (currentEditingAgent !== null && agents[currentEditingAgent] && agents[currentEditingAgent].useGlobal === false) {
                        const v = parseInt(el.agentMaxTokens.value, 10);
                        agents[currentEditingAgent].maxTokens = isNaN(v) ? 2000 : v;
                        saveData();
                    }
                });
            }

            el.createGroupBtn.addEventListener('click', openGroupModal);
            el.cancelGroupModalBtn.addEventListener('click', closeGroupModal);
            el.groupForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveGroup();
            });
            el.groupAutoReply.addEventListener('change', updateGroupAutoReplyUI);
            if (el.groupAutoReplyMode) el.groupAutoReplyMode.addEventListener('change', updateGroupAutoReplyUI);
            if (el.groupSelectorRefreshModelsBtn) el.groupSelectorRefreshModelsBtn.addEventListener('click', loadSelectorModels);

            el.createAgentBtn.addEventListener('click', openAgentModal);
            el.cancelAgentModalBtn.addEventListener('click', closeAgentModal);
            el.agentForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveAgent();
            });

            el.agentUseGlobal.addEventListener('change', toggleAgentConfig);
            el.refreshModelsBtn.addEventListener('click', loadModels);
            if (el.agentRefreshModelsBtn) el.agentRefreshModelsBtn.addEventListener('click', loadAgentModels);

            // Agent TTS bindings
            if (el.agentTTSUseGlobal) el.agentTTSUseGlobal.addEventListener('change', toggleAgentTTSConfig);
            if (el.agentRefreshVoicesBtn) {
                el.agentRefreshVoicesBtn.addEventListener('click', async () => {
                    const useGlobal = el.agentTTSUseGlobal?.checked !== false;
                    const baseUrl = useGlobal ? globalSettings.tts.baseUrl : (el.agentTTSBaseUrl?.value || globalSettings.tts.baseUrl);
                    try {
                        const voices = await fetchVoices(baseUrl);
                        const base = (baseUrl||'').replace(/\/$/,'');
                        ttsVoicesCache.set(base, voices);
                        fillVoiceSelect(el.agentTTSVoice, voices, el.agentTTSVoice?.value || '');
                        fillStyleSelect(el.agentTTSStyle, voices, el.agentTTSVoice?.value || '', el.agentTTSStyle?.value || '');
                        showToast('å·²åˆ·æ–° Voices', 'success');
                    } catch (_) { showToast('åˆ·æ–° Voices å¤±è´¥', 'error'); }
                });
            }
            if (el.agentTTSVoice) {
                el.agentTTSVoice.addEventListener('change', () => {
                    const useGlobal = el.agentTTSUseGlobal?.checked !== false;
                    const baseUrl = useGlobal ? globalSettings.tts.baseUrl : (el.agentTTSBaseUrl?.value || globalSettings.tts.baseUrl);
                    const base = (baseUrl||'').replace(/\/$/,'');
                    const voices = ttsVoicesCache.get(base) || [];
                    fillStyleSelect(el.agentTTSStyle, voices, el.agentTTSVoice.value, el.agentTTSStyle?.value || '');
                });
            }

            el.toggleSidebarBtn.addEventListener('click', toggleSidebar);
            el.toggleRightSidebarBtn.addEventListener('click', toggleRightSidebar);
            if (el.collapseLeftSidebarBtn) el.collapseLeftSidebarBtn.addEventListener('click', toggleSidebar);
            if (el.collapseRightSidebarBtn) el.collapseRightSidebarBtn.addEventListener('click', toggleRightSidebar);
            el.editGroupBtn.addEventListener('click', editCurrentGroup);
            el.clearChatBtn.addEventListener('click', clearChat);
            el.sendBtn.addEventListener('click', sendMessage);
            el.sendBtn.addEventListener('mousedown', e => {
                e.preventDefault(); // é˜»æ­¢ç‚¹å‡»æ—¶è®© input å¤±ç„¦
            });
            if (el.mentionMenu) {
                el.mentionMenu.addEventListener('click', (e) => {
                    const item = e.target.closest('.mention-item');
                    if (!item) return;
                    mentionState.selected = parseInt(item.getAttribute('data-index')) || 0;
                    chooseMention();
                });
            }
            document.addEventListener('click', (e) => {
                if (!el.mentionMenu) return;
                if (mentionState.open && !el.mentionMenu.contains(e.target) && e.target !== el.userInput) {
                    closeMention();
                }
            });
            window.addEventListener('resize', () => { if (mentionState.open) positionMentionMenu(); });

            // èŠå¤©åŒºäº¤äº’ï¼šå–æ¶ˆã€å·¥å…·æ¡ã€å¤´åƒç‚¹å‡»
            el.chatMessages.addEventListener('click', (e) => {
                const cancelBtn = e.target.closest('[data-action="cancel-msg"]');
                if (cancelBtn) {
                    const msgId = cancelBtn.getAttribute('data-msg-id');
                    const run = inflight.get(msgId);
                    try { run?.stream?.controller?.abort?.(); } catch (_) {}
                    if (run?.ac) run.ac.abort();
                    // æ ‡è®°è¯¥è§’è‰²æ¶ˆæ¯ä¸º canceledï¼Œå¹¶è®°å½•ç³»ç»Ÿæç¤º
                    const group = groups.find(g => g.id === currentGroupId);
                    if (group && Array.isArray(group.messages)) {
                        const m = group.messages.find(m => m.id === msgId);
                        if (m && m.role === 'assistant' && m.status === 'streaming') {
                            m.status = 'canceled';
                            saveData();
                            renderMessages();
                            const agent = agents.find(a => a.id === m.agentId);
                            addSystemMessage(group, `ç”¨æˆ·ä¸­æ­¢äº† ${agent ? agent.name : 'è¯¥è§’è‰²'} çš„å“åº”`, 'info');
                        }
                    }
                    return;
                }
                // æ€è€ƒè¿‡ç¨‹å±•å¼€/æŠ˜å 
                const thinkToggle = e.target.closest('.ms-think-toggle');
                if (thinkToggle) {
                    const msgRoot = thinkToggle.closest('.message');
                    const thinkEl = msgRoot ? msgRoot.querySelector('.message-thinking') : null;
                    if (thinkEl) {
                        const nowHidden = thinkEl.classList.toggle('hidden');
                        thinkToggle.setAttribute('aria-expanded', (!nowHidden).toString());
                    }
                    return;
                }
                // å·¥å…·æ¡ï¼šå¤åˆ¶/å¯¼å‡º
                const toolBtn = e.target.closest('[data-action="copy-msg"], [data-action="export-msg"]');
                if (toolBtn) {
                    e.stopPropagation();
                    const msgRoot = toolBtn.closest('.message');
                    const content = getMessageMarkdownFromEl(msgRoot);
                    const name = (msgRoot?.querySelector('.message-name')?.textContent || 'message').trim();
                    const id = msgRoot?.getAttribute('data-msg-id') || '';
                    if (toolBtn.matches('[data-action="copy-msg"]')) {
                        if (!content) { showToast('æš‚æ— å¯å¤åˆ¶å†…å®¹', 'warning'); return; }
                        const copy = async () => {
                            try {
                                if (navigator.clipboard?.writeText) await navigator.clipboard.writeText(content);
                                else {
                                    const ta = document.createElement('textarea');
                                    ta.value = content; ta.style.position = 'fixed'; ta.style.opacity = '0';
                                    document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
                                }
                                showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                            } catch (_) { showToast('å¤åˆ¶å¤±è´¥', 'error'); }
                        };
                        copy();
                    } else {
                        if (!content) { showToast('æš‚æ— å¯å¯¼å‡ºå†…å®¹', 'warning'); return; }
                        const safe = (s) => (s || '').replace(/[^\u4e00-\u9fa5\w\-]+/g, '_').replace(/^_+|_+$/g, '').slice(0, 40) || 'message';
                        const ts = new Date().toISOString().replace(/[:T]/g, '-').slice(0, 19);
                        const filename = `${safe(name)}${id ? '-' + id.slice(0, 8) : ''}-${ts}.md`;
                        downloadFile(filename, content);
                        showToast('å·²å¯¼å‡º Markdown æ–‡ä»¶', 'success');
                    }
                    return;
                }
                // è¯­éŸ³æœ—è¯»ï¼šå•ä¸ªæ°”æ³¡
                const readBtn = e.target.closest('[data-action="tts-read"]');
                if (readBtn) {
                    e.stopPropagation();
                    const bubble = qs('.vditor-reset', readBtn.closest('.message-text'));
                    const msgRoot = readBtn.closest('.message');
                    const msgId = msgRoot?.getAttribute('data-msg-id') || '';
                    const text = getBubblePlainText(bubble);
                    // åˆ‡æ¢ä¸ºåŠ è½½çŠ¶æ€
                    try {
                        if (!readBtn.dataset.label) readBtn.dataset.label = readBtn.textContent || 'ğŸ”Š';
                        readBtn.disabled = true;
                        readBtn.classList.add('loading');
                        readBtn.textContent = 'â³';
                    } catch (_) {}
                    playTTS(text, msgId, bubble, readBtn);
                    return;
                }
                // ç§»åŠ¨ç«¯ï¼šç‚¹å‡»æ¶ˆæ¯å†…å®¹æ˜¾ç¤ºå·¥å…·æ¡ï¼Œå¹¶é‡ç½®å•ä¸€è®¡æ—¶å™¨
                if (isMobileView()) {
                    const contentEl = e.target.closest('.message-content');
                    if (contentEl && !e.target.closest('[data-action]') && !e.target.closest('.ms-think-toggle')) {
                        const show = contentEl.classList.toggle('show-tools');
                        const prev = mobileToolsTimers.get(contentEl);
                        if (prev) clearTimeout(prev);
                        if (show) {
                            const t = setTimeout(() => {
                                contentEl.classList.remove('show-tools');
                                mobileToolsTimers.delete(contentEl);
                            }, 2500);
                            mobileToolsTimers.set(contentEl, t);
                        }
                        return;
                    }
                }
                // welcome-actions å¿«æ·æ“ä½œ
                if (e.target.closest('#welcomeSettingsBtn')) { openUserSettingsModal(); return; }
                if (e.target.closest('#welcomeCreateAgentBtn')) { openAgentModal(); return; }
                if (e.target.closest('#welcomeCreateGroupBtn')) { openGroupModal(); return; }
                if (e.target.closest('#welcomeSelectGroupBtn')) {
                    const leftSidebar = qs('.sidebar');
                    if (leftSidebar && leftSidebar.classList.contains('hidden')) {
                        leftSidebar.classList.remove('hidden');
                        localStorage.setItem('sidebarHidden', 'false');
                        updateMobileSidebarState();
                        updateDesktopPushState();
                    }
                    return;
                }

                const avatar = e.target.closest('.message-avatar');
                if (!avatar) return;
                const id = avatar.getAttribute('data-agent-id');
                if (id) {
                    const idx = agents.findIndex(a => a.id === id);
                    if (idx !== -1) editAgent(idx);
                } else {
                    openUserSettingsModal();
                }
            });

            // ä»…å½“ç”¨æˆ·ä½äºåº•éƒ¨æ—¶è‡ªåŠ¨ç½®åº•ï¼Œå¹¶åœ¨æœªç½®åº•æ—¶æ˜¾ç¤ºæ‚¬æµ®æŒ‰é’®
            el.chatMessages.addEventListener('scroll', () => {
                shouldAutoScroll = isAtBottom(el.chatMessages);
                if (el.scrollToBottomBtn) {
                    el.scrollToBottomBtn.classList.toggle('show', !shouldAutoScroll);
                }
            });

            if (el.scrollToBottomBtn) {
                el.scrollToBottomBtn.addEventListener('click', () => {
                    shouldAutoScroll = true;
                    scrollToBottom(true);
                });
                // åˆå§‹åŒ–æŒ‰é’®å¯è§æ€§
                el.scrollToBottomBtn.classList.toggle('show', !isAtBottom(el.chatMessages));
            }

            el.agentList.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('[data-action="delete-agent"]');
                const removeBtn = e.target.closest('[data-action="remove-from-group"]');
                if (deleteBtn) {
                    e.stopPropagation();
                    deleteAgent(parseInt(deleteBtn.dataset.index));
                    return;
                }
                if (removeBtn) {
                    e.stopPropagation();
                    removeAgentFromCurrentGroup(removeBtn.dataset.agentId);
                    return;
                }
                // ç‚¹å‡»â€œå½“å‰ç”¨æˆ·â€æ¡ç›®ï¼Œæ‰“å¼€ç”¨æˆ·è®¾ç½®
                const userEntry = e.target.closest('[data-user-entry="true"]');
                if (userEntry) {
                    e.stopPropagation();
                    openUserSettingsModal();
                    return;
                }
                const item = e.target.closest('.agent-item');
                if (item) {
                    const id = item.getAttribute('data-agent-id');
                    const idx = agents.findIndex(a => a.id === id);
                    if (idx !== -1) editAgent(idx);
                }
            });

            if (el.permVisionType) {
                el.permVisionType.addEventListener('change', () => {
                    const show = el.permVisionType.value === 'custom';
                    el.permVisionExprWrap.style.display = show ? '' : 'none';
                });
            }
            if (el.permVisionExpr) {
                el.permVisionExpr.addEventListener('input', validatePermVisionExprLive);
            }

            el.groupList.addEventListener('click', (e) => {
                const moreBtn = e.target.closest('[data-action="group-more"]');
                if (moreBtn) {
                    e.stopPropagation();
                    const idx = moreBtn.dataset.index;
                    qsa('.dropdown-menu').forEach(m => m.classList.remove('open'));
                    const menu = qs(`.dropdown-menu[data-menu-for="${idx}"]`);
                    if (menu) menu.classList.toggle('open');
                    return;
                }

                const editBtn = e.target.closest('[data-action="edit-group"]');
                const delBtn = e.target.closest('[data-action="delete-group"]');
                if (editBtn || delBtn) {
                    e.stopPropagation();
                    qsa('.dropdown-menu').forEach(m => m.classList.remove('open'));
                }
                const item = e.target.closest('.item[data-group-id]');
                
                if (editBtn) editGroup(parseInt(editBtn.dataset.index));
                else if (delBtn) deleteGroup(parseInt(delBtn.dataset.index));
                else if (item) {
                    selectGroup(item.dataset.groupId);
                    // ç§»åŠ¨ç«¯ç‚¹å‡»åéšè—å·¦ä¾§æŠ½å±‰
                    if (isMobileView()) {
                        const leftSidebar = qs('.sidebar');
                        if (leftSidebar && !leftSidebar.classList.contains('hidden')) {
                            leftSidebar.classList.add('hidden');
                            localStorage.setItem('sidebarHidden', 'true');
                            updateMobileSidebarState();
                        }
                    }
                }
            });

            if (el.sidebarOverlay) {
                el.sidebarOverlay.addEventListener('click', closeMobileSidebars);
            }

            // é€šç”¨ï¼šç‚¹å‡»æ¨¡æ€æ¡†ç©ºç™½åŒºåŸŸå…³é—­ï¼ˆé€‚ç”¨äºæ‰€æœ‰ .modal.activeï¼‰
            document.addEventListener('click', (ev) => {
                const actives = qsa('.modal.active');
                if (!actives.length) return;
                const top = actives[actives.length - 1];
                if (!top.contains(ev.target)) return; // ç‚¹å‡»ä¸åœ¨è¯¥æ¨¡æ€å†…ï¼Œå¿½ç•¥
                const content = top.querySelector('.modal-content');
                if (content && !content.contains(ev.target)) {
                    top.classList.remove('active');
                }
            });

            // ç‚¹å‡»ç©ºç™½å¤„å…³é—­æ›´å¤šèœå•
            document.addEventListener('click', (ev) => {
                const isMore = ev.target.closest('.more-wrap');
                if (!isMore) qsa('.dropdown-menu').forEach(m => m.classList.remove('open'));
            });

            // ç‚¹å‡»ç©ºç™½å¤„éšè—æ¶ˆæ¯å·¥å…·æ¡ï¼ˆç§»åŠ¨ç«¯ï¼‰
            document.addEventListener('click', (ev) => {
                const withinMessage = ev.target.closest('.message-content');
                if (!withinMessage) qsa('.message-content.show-tools').forEach(n => n.classList.remove('show-tools'));
            });

            document.addEventListener('keydown', handleGlobalKeydown);
            window.addEventListener('resize', () => { updateMobileSidebarState(); updateDesktopPushState(); applyDefaultSidebarHiddenIfNonDesktop(); });
        }

        function updateUserDisplay() {
            el.userNameDisplay.textContent = globalSettings.userName;
        }

        // Ensure each modal opens at the top rather than previous scroll position
        function resetModalScroll(modalEl) {
            if (!modalEl) return;
            modalEl.scrollTop = 0;
            const content = modalEl.querySelector('.modal-content');
            if (content) {
                content.scrollTop = 0;
                const form = content.querySelector('form');
                if (form) form.scrollTop = 0;
            }
        }

        function openUserSettingsModal() {
            updateModelSelects();
            el.userNickname.value = globalSettings.userName;
            el.globalBaseUrl.value = globalSettings.baseUrl;
            el.globalApiKey.value = globalSettings.apiKey;
            el.globalModel.value = globalSettings.model;
            // TTS
            if (el.globalTTSBaseUrl) el.globalTTSBaseUrl.value = globalSettings.tts?.baseUrl || '';
            if (el.globalTTSApiKey) el.globalTTSApiKey.value = globalSettings.tts?.apiKey || '';
            if (el.globalTTSRate) el.globalTTSRate.value = globalSettings.tts?.rate ?? 0;
            if (el.globalTTSPitch) el.globalTTSPitch.value = globalSettings.tts?.pitch ?? 0;
            if (el.globalTTSFormat) el.globalTTSFormat.value = globalSettings.tts?.format || '';
            if (el.globalTTSVoice) {
                const base = (globalSettings.tts?.baseUrl||'').replace(/\/$/,'');
                const voices = ttsVoicesCache.get(base) || [];
                fillVoiceSelect(el.globalTTSVoice, voices, globalSettings.tts?.voice || '');
                fillStyleSelect(el.globalTTSStyle, voices, el.globalTTSVoice.value, globalSettings.tts?.style || '');
            }
            if (el.systemMsgLevel) {
                el.systemMsgLevel.value = globalSettings.systemMsgLevel || 'all';
            }
            if (el.themeMode) {
                el.themeMode.value = globalSettings.themeMode || 'system';
            }
            el.userSettingsModal.classList.add('active');
            resetModalScroll(el.userSettingsModal);
        }

        function closeUserSettingsModal() {
            el.userSettingsModal.classList.remove('active');
        }

        async function saveUserSettings() {
            globalSettings.userName = el.userNickname.value;
            globalSettings.baseUrl = el.globalBaseUrl.value;
            globalSettings.apiKey = el.globalApiKey.value;
            globalSettings.model = el.globalModel.value;
            // TTS
            if (!globalSettings.tts) globalSettings.tts = {};
            globalSettings.tts.baseUrl = el.globalTTSBaseUrl?.value || globalSettings.tts.baseUrl;
            globalSettings.tts.apiKey = el.globalTTSApiKey?.value || globalSettings.tts.apiKey;
            globalSettings.tts.voice = el.globalTTSVoice?.value || globalSettings.tts.voice;
            globalSettings.tts.style = el.globalTTSStyle?.value || globalSettings.tts.style;
            globalSettings.tts.rate = parseInt(el.globalTTSRate?.value || '0', 10) || 0;
            globalSettings.tts.pitch = parseInt(el.globalTTSPitch?.value || '0', 10) || 0;
            globalSettings.tts.format = el.globalTTSFormat?.value || globalSettings.tts.format;
            if (el.systemMsgLevel) {
                globalSettings.systemMsgLevel = el.systemMsgLevel.value || 'all';
            }
            if (el.themeMode) {
                globalSettings.themeMode = el.themeMode.value || 'system';
            }

            saveData();
            updateUserDisplay();
            await initOpenAI();
            closeUserSettingsModal();
            showToast('è®¾ç½®å·²ä¿å­˜', 'success');
            if (currentGroupId) {
                renderMessages();
            }

            // åº”ç”¨ä¸»é¢˜ï¼ˆåŒ…æ‹¬è·Ÿéšç³»ç»Ÿï¼‰
            applyTheme(globalSettings.themeMode || 'system');
        }

        function renderAgents() {
            const group = groups.find(g => g.id === currentGroupId);
            const list = group ? agents.filter(a => (group.agentIds || []).includes(a.id)) : [];

            if (!group) {
                el.agentList.innerHTML = '<div class="empty-state"><p>å…ˆé€‰æ‹©ä¸€ä¸ªç¾¤èŠ</p></div>';
                return;
            }

            // ä¸å†åœ¨åˆ—è¡¨ä¸ºç©ºæ—¶æå‰è¿”å›ï¼›ä¿æŒæ˜¾ç¤ºâ€œå½“å‰ç”¨æˆ·â€

            const isAll = group.isAllAgentsGroup === true;
            // prepend current user as a pseudo member on top
            const userItemHtml = `
                <div class="item" data-user-entry="true">
                    <div class="item-header">
                        <div class="item-name">
                            <span class="agent-color" style="background: #667eea"></span>
                            ${escapeHtml(globalSettings.userName)} <span class="role-muted">(ç”¨æˆ·)</span>
                        </div>
                        <div class="item-actions" style="margin-top:0;"></div>
                    </div>
                    <div class="item-desc" style="font-size: 11px;">æ¨¡å‹: ${globalSettings.model || '-'}</div>
                </div>`;

            const agentsHtml = list.map((agent) => {
                const config = resolveAgentConfig(agent, globalSettings);
                const idx = agents.findIndex(a => a.id === agent.id);
                const actions = isAll
                    ? `<button class="icon-btn icon-btn-danger" title="åˆ é™¤" aria-label="åˆ é™¤" data-action="delete-agent" data-index="${idx}">ğŸ—‘ï¸</button>`
                    : `<button class="icon-btn icon-btn-danger" title="ç§»é™¤" aria-label="ç§»é™¤" data-action="remove-from-group" data-agent-id="${agent.id}">ğŸ—‘ï¸</button>`;
                return `
                    <div class="item agent-item" data-agent-id="${agent.id}">
                        <div class="item-header">
                            <div class="item-name">
                                <span class="agent-color" style="background: ${agent.color}"></span>
                                ${agent.name} ${agent.role ? `<span class=\"role-muted\">${agent.role}</span>` : ''}
                            </div>
                            <div class="item-actions" style="margin-top:0;">${actions}</div>
                        </div>
                        <div class="item-desc" style="font-size: 11px;">æ¨¡å‹: ${config.model || 'gpt-3.5-turbo'}</div>
                    </div>
                `;
            }).join('');
            el.agentList.innerHTML = userItemHtml + agentsHtml;
        }

        function renderGroups() {
            if (groups.length === 0) {
                el.groupList.innerHTML = '<div class="empty-state"><p>è¿˜æ²¡æœ‰ç¾¤èŠ<br>ç‚¹å‡»ä¸‹æ–¹åˆ›å»º</p></div>';
                return;
            }

            el.groupList.innerHTML = groups.map((group, index) => {
                const groupAgents = group.agentIds.map(id => agents.find(a => a.id === id)).filter(a => a);
                const isAll = group.isAllAgentsGroup === true;
                const participants = (groupAgents.length + 1);
                const more = isAll ? '' : `
                    <div class="more-wrap">
                        <button class="icon-btn" data-action="group-more" data-index="${index}" aria-label="æ›´å¤š"><span style="font-size: 4px;">ğŸ”˜ ğŸ”˜ ğŸ”˜</span></button>
                        <div class="dropdown-menu" data-menu-for="${index}">
                            <div class="dropdown-item" data-action="edit-group" data-index="${index}">ç¼–è¾‘</div>
                            <div class="dropdown-item dropdown-item-danger" data-action="delete-group" data-index="${index}">åˆ é™¤</div>
                        </div>
                    </div>`;
                return `
                    <div class="item ${currentGroupId === group.id ? 'active' : ''}" data-group-id="${group.id}">
                        <div class="item-header">
                            <div class="item-name">${group.name} <span class="role-muted">(${participants})</span></div>
                            ${more}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // key -> markdown element ç¼“å­˜
        const messageElementCache = new Map();
        const MAX_CACHE = 400; // ç®€æ˜“ LRU ä¸Šé™
        function cacheSet(key, el) {
            messageElementCache.set(key, el);
            if (messageElementCache.size > MAX_CACHE) {
                const oldest = messageElementCache.keys().next().value;
                messageElementCache.delete(oldest);
            }
        }

        const hash = (str) => {
            let hash = 0;
            if (str.length === 0) {
                return hash;
            }
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char; // hash * 31 + char
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash;
        }

        const createElement = (html) => {
            // æ¥æ”¶ä¸€ä¸ª html æ–‡æœ¬, è¿”å›ä¸€ä¸ª html èŠ‚ç‚¹å…ƒç´ 
            // æ¯”å¦‚ html = <div class="message-text">Hello</div>"
            const temp = document.createElement('div');
            temp.innerHTML = html;
            return temp.firstElementChild;
        }

        // Markdown é¢„è§ˆåˆå¹¶æ¸²æŸ“å™¨ï¼šèŠ‚æµ + å°¾è§¦å‘ + maxWaitï¼ˆæŒ‰å…ƒç´ ç»´åº¦ï¼‰
        const previewStates = new WeakMap(); // el -> { timer, lastRender, pending }
        // minDelay æœ€çŸ­åˆå¹¶ç­‰å¾…æ—¶é—´, ç”¨äºèŠ‚æµ, maxDelay æœ€é•¿ä¸æ›´æ–°ç­‰å¾…æ—¶é—´, ç”¨äºå°¾è§¦å‘
        function schedulePreview(el, text, opts, minDelay = 60, maxDelay = 180) {
            if (!el) return;
            let st = previewStates.get(el);
            if (!st) {
                st = { timer: null, lastRender: 0, pending: '' };
                previewStates.set(el, st);
            }
            if (st.pending === text) return;

            if (st.timer != null) {
                clearTimeout(st.timer);
                st.timer = null;
            }

            // æ›´æ–°å¾…æ¸²æŸ“æ–‡æœ¬ï¼ˆä¿ç•™æœ€æ–°ï¼‰
            const currentPending = text;

            const now = performance.now();
            const since = now - (st.lastRender || 0);
            const hasUpdate = maxDelay <= since;
            // delay ä¸º 0 è¡¨ç¤ºç«‹å³åˆ·æ–°æ¸²æŸ“, 
            // æ‰€ä»¥å½“ hasUpdate ä¸º true æ—¶, ä¼šç«‹å³åˆ·æ–°
            // ä»¥åŠå½“ since å¤§äº minDelay æ—¶, ä¹Ÿä¼šç«‹å³åˆ·æ–°
            // å¦åˆ™å°±æ˜¯æ‰§è¡ŒèŠ‚æµç­–ç•¥, æŒ‰æœ€çŸ­åˆå¹¶ç­‰å¾…æ—¶é—´å»¶è¿Ÿåˆ·æ–°
            const delay = hasUpdate ? 0 : Math.max(minDelay - since, 0);

            st.timer = window.setTimeout(async () => {
                st.timer = null;
                const textToRender = autoCloseCodeBlock(currentPending.trim());
                Vditor.preview(el, autoCloseCodeBlock(textToRender), opts);
                st.lastRender = performance.now();
                st.pending = currentPending;
            }, delay);
            // previewStates.set(el, st);
        }

        const createMarkdownElement = (id, text) => {
            const messageTextEleHTML = `<div class="message-text" data-md-enc=""><div class="vditor-reset">${text}</div><button class="tts-read-btn" data-action="tts-read" title="æœ—è¯»" aria-label="æœ—è¯»">ğŸ”Š</button></div>`;
            const key = id;
            const mdel = messageElementCache.has(key) ? messageElementCache.get(key) : createElement(messageTextEleHTML);
            const textencode = encodeURIComponent(text||'');
            // è·å– el çš„ data-md-enc å€¼
            const mdencode = mdel.getAttribute('data-md-enc') || "";
            if (textencode !== mdencode) {
                mdel.setAttribute('data-md-enc', textencode);
                const opts = {
                    hljs: {
                        enable: true,
                        style: globalSettings.themeMode === "dark" ? "base16/dracula" : "github"
                    },
                    after: () => {
                        if (shouldAutoScroll) {
                            el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
                        }
                    }
                };
                schedulePreview(qs('.vditor-reset', mdel), text, opts, 60, 180);
                cacheSet(key, mdel);
            }
            return mdel;
        }

        // æ¯æ¡æ¶ˆæ¯å†…å®¹åŒºåŸŸçš„ç§»åŠ¨ç«¯å·¥å…·æ¡éšè—è®¡æ—¶å™¨
        const mobileToolsTimers = new WeakMap();

        // TTS caches
        const ttsAudioCache = new Map(); // key -> ObjectURL
        const ttsVoicesCache = new Map(); // baseUrl -> voices array
        let currentAudio = null;

        // ===== å·¥å…·ï¼šæå–æ¶ˆæ¯ Markdownã€ä¸‹è½½æ–‡ä»¶ã€ç§»åŠ¨ç«¯åˆ¤æ–­ =====
        function getMessageMarkdownFromEl(msgRoot) {
            if (!msgRoot) return '';
            const nodes = Array.from(msgRoot.querySelectorAll('.message-content .message-text'));
            if (!nodes.length) return '';
            const parts = nodes.map(n => {
                const enc = n.getAttribute('data-md-enc');
                if (enc) {
                    try { return decodeURIComponent(enc); } catch (_) { return n.innerText || ''; }
                }
                return n.innerText || '';
            });
            return parts.join('\n\n').trim();
        }

        function downloadFile(filename, content, mime = 'text/markdown;charset=utf-8') {
            const blob = new Blob([content], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
        }

        function getBubblePlainText(bubble) {
            if (!bubble) return '';
            return (bubble.innerText || '').trim();
        }

        // è¿‡æ»¤åŠ©æ‰‹è¾“å‡ºä¸­çš„å‰ç¼€å½¢å¦‚ [è§’è‰²å]: æˆ– [Name]ï¼šâ€”â€”å…¨é‡æ¸…æ´—ï¼ˆä¸é™å¼€å¤´ï¼‰
        function stripRoleNamePrefix(text) {
            if (!text) return text;
            return text.replace(/\[[^\]\n]{1,32}\]\s*[:ï¼š]\s*/g,'');
        }

        // æœ—è¯»ä¸“ç”¨ï¼šç§»é™¤ emoji åŠå˜ä½“é€‰æ‹©ç¬¦/é›¶å®½è¿æ¥ç¬¦ï¼Œé¿å… TTS å¼‚å¸¸æˆ–ä¸è‡ªç„¶åœé¡¿
        function stripEmojisForTTS(text) {
            if (!text) return text;
            // å¸¸è§ emoji é«˜ä»£ç†å¯¹ã€æ‚é¡¹ç¬¦å·ã€å˜ä½“é€‰æ‹©ç¬¦ä¸ ZWJ
            const re = /([\u2700-\u27BF]|[\uE000-\uF8FF]|[\uD83C-\uDBFF][\uDC00-\uDFFF]|[\u2011-\u26FF]|\uFE0F|\u200D)/g;
            return text.replace(re, '');
        }

        function clearAllTTSProgress() {
            qsa('.tts-progress-inline').forEach(el => el.remove());
        }

        function createTTSProgressInline(messageTextEl) {
            if (!messageTextEl) return null;
            const bar = document.createElement('div');
            bar.className = 'tts-progress-inline';
            bar.innerHTML = '<div class="fill"></div>';
            messageTextEl.appendChild(bar);
            return bar;
        }

        function resolveTTSConfig(agent, global) {
            const g = global.tts || {};
            if (!agent || agent.ttsUseGlobal !== false) {
                return { ...g };
            }
            const a = agent.tts || {};
            return {
                baseUrl: a.baseUrl || g.baseUrl,
                apiKey: a.apiKey || g.apiKey,
                voice: a.voice || g.voice,
                style: a.style || g.style || 'general',
                rate: (a.rate !== undefined ? a.rate : g.rate || 0),
                pitch: (a.pitch !== undefined ? a.pitch : g.pitch || 0),
                format: a.format || g.format || 'audio-24khz-48kbitrate-mono-mp3'
            };
        }

        function buildTTSUrl(text, cfg) {
            const u = new URL((cfg.baseUrl || '').replace(/\/$/, '') + '/tts');
            if (cfg.apiKey) u.searchParams.set('api_key', cfg.apiKey);
            u.searchParams.set('t', text);
            if (cfg.voice) u.searchParams.set('v', cfg.voice);
            if (cfg.rate !== undefined) u.searchParams.set('r', String(cfg.rate));
            if (cfg.pitch !== undefined) u.searchParams.set('p', String(cfg.pitch));
            if (cfg.style) u.searchParams.set('s', cfg.style);
            if (cfg.format) u.searchParams.set('o', cfg.format);
            return u.toString();
        }

        async function playTTS(text, msgId, bubbleEl, btnEl) {
            const group = groups.find(g => g.id === currentGroupId);
            const msg = group?.messages?.find(m => m.id === msgId);
            const agent = (msg && msg.role === 'assistant') ? agents.find(a => a.id === msg.agentId) : null;
            const cfg = resolveTTSConfig(agent, globalSettings);
            const plain = stripEmojisForTTS((text || '').trim());
            if (!plain) { showToast('æš‚æ— å¯æœ—è¯»å†…å®¹', 'warning'); return; }
            if (!cfg.baseUrl) { showToast('è¯·å…ˆé…ç½® TTS Base URL', 'warning'); return; }
            const key = hash(`${plain}|${JSON.stringify(cfg)}`);
            console.log('tts cache key:', key);
            
            try {
                if (currentAudio) { try { currentAudio.pause(); } catch (_) {} }
                let src = ttsAudioCache.get(key);
                if (!src) {
                    const url = buildTTSUrl(plain, cfg);
                    const resp = await fetch(url);
                    if (!resp.ok) throw new Error('TTS è¯·æ±‚å¤±è´¥');
                    const blob = await resp.blob();
                    src = URL.createObjectURL(blob);
                    ttsAudioCache.set(key, src);
                }
                const audio = new Audio(src);
                currentAudio = audio;
                // è¿›åº¦æ¡ï¼šæ¸…ç†æ—§çš„ï¼Œç»‘å®šä¸ºâ€œè´´åº•è¾¹æ¡†â€æ ·å¼ï¼ˆæ°”æ³¡å†…éƒ¨ç»å¯¹å®šä½ï¼‰
                clearAllTTSProgress();
                const messageTextEl = bubbleEl?.closest('.message-text');
                const bar = createTTSProgressInline(messageTextEl);
                const fill = bar?.querySelector('.fill');
                const setProgress = () => {
                    if (!fill || !audio.duration || !isFinite(audio.duration)) return;
                    const pct = Math.max(0, Math.min(1, audio.currentTime / audio.duration)) * 100;
                    fill.style.width = pct.toFixed(2) + '%';
                };
                const restoreBtn = () => { try { if (btnEl) { btnEl.disabled = false; btnEl.classList.remove('loading'); btnEl.textContent = btnEl.dataset.label || 'ğŸ”Š'; } } catch (_) {} };
                audio.addEventListener('playing', () => { restoreBtn(); setProgress(); }, { once: true });
                audio.addEventListener('timeupdate', setProgress);
                audio.addEventListener('error', () => { restoreBtn(); if (bar) bar.remove(); }, { once: true });
                audio.addEventListener('ended', () => { try { if (btnEl) btnEl.textContent = btnEl.dataset.label || 'ğŸ”Š'; } catch (_) {} if (bar) bar.remove(); }, { once: true });
                audio.play().catch(()=>{ restoreBtn(); });
            } catch (e) {
                try { if (btnEl) { btnEl.disabled = false; btnEl.classList.remove('loading'); btnEl.textContent = btnEl.dataset.label || 'ğŸ”Š'; } } catch (_) {}
                showToast('æœ—è¯»å¤±è´¥', 'error');
            }
        }

        async function fetchVoices(baseUrl) {
            const key = (baseUrl || '').replace(/\/$/, '');
            if (ttsVoicesCache.has(key)) return ttsVoicesCache.get(key);
            const url = key + '/voices';
            const resp = await fetch(url);
            if (!resp.ok) throw new Error('è·å– voices å¤±è´¥');
            const data = await resp.json();
            ttsVoicesCache.set(key, data);
            return data;
        }

        function fillVoiceSelect(selectEl, voices, current) {
            if (!selectEl) return;
            // Reset with placeholder
            selectEl.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = '-- é€‰æ‹© Voice --';
            selectEl.appendChild(placeholder);

            const list = Array.isArray(voices) ? voices.slice() : [];
            // Group by Locale
            const byLocale = new Map();
            for (const v of list) {
                const key = v.Locale || 'Other';
                if (!byLocale.has(key)) byLocale.set(key, []);
                byLocale.get(key).push(v);
            }
            // Sort locales and voices for stable UI
            const locales = Array.from(byLocale.keys()).sort((a,b)=>a.localeCompare(b));
            for (const locale of locales) {
                const groupEl = document.createElement('optgroup');
                groupEl.label = locale;
                const vs = byLocale.get(locale).sort((a,b)=> (a.ShortName||'').localeCompare(b.ShortName||''));
                for (const v of vs) {
                    const opt = document.createElement('option');
                    opt.value = v.ShortName;
                    const gender = v.Gender === 'Female' ? 'â™€' : (v.Gender === 'Male' ? 'â™‚' : 'â€¢');
                    opt.textContent = `${gender} ${v.ShortName}${(v.LocalName && v.ShortName.length < 36 && v.LocalName !== v.ShortName) ? ` / ${v.LocalName}` : ''}`;
                    groupEl.appendChild(opt);
                }
                selectEl.appendChild(groupEl);
            }

            if (current) {
                let has = Array.from(selectEl.options).some(o => o.value === current);
                if (!has) {
                    const orphan = document.createElement('option');
                    orphan.value = current;
                    orphan.textContent = current;
                    selectEl.appendChild(orphan);
                }
                selectEl.value = current;
            }
        }

        function fillStyleSelect(selectEl, voices, voiceValue, currentStyle) {
            if (!selectEl) return;
            let styles = [];
            if (voices && voiceValue) {
                const v = voices.find(x => x.ShortName === voiceValue);
                styles = v?.StyleList || [];
            }
            const options = [''].concat(styles).map(s => `<option value="${s}">${s||'-- è‡ªåŠ¨ --'}</option>`).join('');
            selectEl.innerHTML = options;
            if (currentStyle) selectEl.value = currentStyle;
        }

        /**
         * æ£€æŸ¥å¹¶è‡ªåŠ¨é—­åˆæœªå®Œæˆçš„Markdownä»£ç å— (```).
         *
         * @param {string} text - éœ€è¦æ£€æŸ¥çš„åŸå§‹æ–‡æœ¬.
         * @returns {string} - å¦‚æœä»£ç å—æœªé—­åˆï¼Œåˆ™è¿”å›è¿½åŠ äº†é—­åˆç¬¦çš„æ–‡æœ¬ï¼›å¦åˆ™è¿”å›åŸæ–‡æœ¬.
         */
        function autoCloseCodeBlock(text) {
            // 1. å‚æ•°æ ¡éªŒï¼šç¡®ä¿è¾“å…¥æ˜¯å­—ç¬¦ä¸²
            if (typeof text !== 'string') {
                console.error("Input must be a string.");
                return text;
            }

            // 2. ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å…¨å±€åŒ¹é… (g) '```' çš„æ‰€æœ‰å‡ºç°
            //    text.match(/```/g) ä¼šè¿”å›ä¸€ä¸ªåŒ…å«æ‰€æœ‰åŒ¹é…é¡¹çš„æ•°ç»„ï¼Œ
            //    å¦‚æœä¸€æ¬¡ä¹Ÿæ²¡åŒ¹é…åˆ°ï¼Œå®ƒä¼šè¿”å› null.
            const matches = text.match(/```/g);

            // 3. è®¡ç®—åŒ¹é…æ¬¡æ•°
            //    å¦‚æœ matches ä¸º null (0æ¬¡åŒ¹é…)ï¼Œåˆ™æ¬¡æ•°ä¸º 0.
            //    å¦åˆ™ï¼Œæ¬¡æ•°å°±æ˜¯åŒ¹é…æ•°ç»„çš„é•¿åº¦.
            const count = matches ? matches.length : 0;

            // 4. æ ¸å¿ƒé€»è¾‘ï¼šæ£€æŸ¥å¥‡å¶æ€§
            //    å¦‚æœ count æ˜¯å¥‡æ•° (ä¾‹å¦‚ 1, 3, 5...)ï¼Œè¯´æ˜æœ‰ä¸€ä¸ª '```' æ²¡æœ‰é…å¯¹.
            if (count % 2 !== 0) {
                // 5. è¿½åŠ é—­åˆç¬¦.
                //    æˆ‘ä»¬é€šå¸¸åœ¨é—­åˆç¬¦å‰åŠ ä¸€ä¸ªæ¢è¡Œç¬¦ '\n'ï¼Œä»¥ç¡®ä¿æ ¼å¼æ­£ç¡®ï¼Œ
                //    é˜²æ­¢å®ƒç›´æ¥æ‹¼æ¥åˆ°æœ€åä¸€è¡Œä»£ç ä¸Šã€‚
                return text + '\n```';
            }

            // 6. å¦‚æœ count æ˜¯å¶æ•° (0, 2, 4...)ï¼Œè¯´æ˜æ‰€æœ‰ä»£ç å—éƒ½å·²é—­åˆæˆ–æ²¡æœ‰ä»£ç å—.
            return text;
        }

        function renderMessages() {
            const group = groups.find(g => g.id === currentGroupId);
            
            if (!group || !group.messages || group.messages.length === 0) {
                el.chatMessages.innerHTML = `<div class="empty-state">
                <div id="welcomeScreen" class="welcome-screen">
                    <div class="welcome-logo">AITHOS</div>
                    <div class="welcome-actions">
                        <div class="wa-desc">æ‰“å¼€ç”¨æˆ·è®¾ç½®</div><div class="wa-action"><button class="btn btn-secondary" id="welcomeSettingsBtn"><span class="btn-icon">âš™ï¸</span><span class="btn-text">ç”¨æˆ·è®¾ç½®</span></button></div>
                        <div class="wa-desc">åˆ›å»ºè§’è‰²</div><div class="wa-action"><button class="btn btn-secondary" id="welcomeCreateAgentBtn"><span class="btn-icon">ğŸ‘¤</span><span class="btn-text">åˆ›å»ºè§’è‰²</span></button></div>
                        <div class="wa-desc">é€‰æ‹©æˆ–åˆ›å»ºç¾¤èŠ</div><div class="wa-action"><button class="btn btn-secondary" id="welcomeCreateGroupBtn"><span class="btn-icon">âœš</span><span class="btn-text">åˆ›å»ºç¾¤èŠ</span></button><button class="btn btn-secondary" id="welcomeSelectGroupBtn"><span class="btn-icon">â˜°</span><span class="btn-text">é€‰æ‹©ç¾¤èŠ</span></button></div>
                    </div>
                </div>
                </div>`;
                return;
            }

            const progressing = (status) => {
                return (status === 'loading' || status === 'thinking' || status === 'streaming');
            };

            const statusTag = (msg) => {
                if (!msg) return '';
                const s = msg.status;
                if (!s) return 'ERROR(01)';
                const loadingHTML = `ç”Ÿæˆä¸­<span class="dots"><i></i><i></i><i></i></span>`;
                if (s === 'loading') {
                    return loadingHTML;
                }
                if (s === 'thinking') {
                    const hasThinking = ((msg.thinking || '').trim().length > 0);
                    if (!hasThinking) return loadingHTML;
                    return `æ€è€ƒä¸­<span class="dots"><i></i><i></i><i></i></span>`;
                }
                if (s === 'streaming') {
                    return `è¾“å…¥ä¸­<span class="dots"><i></i><i></i><i></i></span>`;
                }
                if (s === 'canceled') return 'å·²ä¸­æ­¢';
                return ''; // Done
            };

            // 1. åˆ›å»ºä¸€ä¸ªç©ºç™½çš„æ–‡æ¡£ç‰‡æ®µ (åœ¨å†…å­˜ä¸­)
            const fragment = document.createDocumentFragment();

            const messageElements = group.messages.map(msg => {
                if (msg.role === 'system') {
                    const lvl = msg.level || 'info';
                    const sel = globalSettings.systemMsgLevel || 'all';
                    if (sel !== 'all' && lvl !== sel) return '';
                    return createElement(`
                        <div class="system-message system-${lvl}">
                            ${escapeHtml(msg.content)}
                        </div>
                    `);
                }
                const isUser = msg.role === 'user';
                // é”™è¯¯/ç©ºå›å¤çš„åŠ©æ‰‹æ¶ˆæ¯ï¼šä¸æ˜¾ç¤ºæ¶ˆæ¯æ°”æ³¡ï¼Œä»…æ˜¾ç¤ºç³»ç»Ÿæç¤ºï¼ˆç”±å…¶ä»–é€»è¾‘æ’å…¥ï¼‰
                if (!isUser && (msg.status === 'error' || msg.status === 'empty')) {
                    return '';
                }
                const agent = isUser ? null : agents.find(a => a.id === msg.agentId);
                const color = isUser ? '#667eea' : (agent ? agent.color : '#999');
                const name = isUser ? globalSettings.userName : (agent ? agent.name : 'æœªçŸ¥');
                let contentElement;
                if (isUser) {
                    if (!msg.id) { msg.id = generateId(); }
                    contentElement = createMarkdownElement(`${msg.id}`, msg.content);
                } else {
                    const st = msg.status || 'done';
                    const text = (msg.content || '').trim();
                    if (st === 'loading' || st === 'thinking') {
                        // ä»…æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºï¼Œä¸æ˜¾ç¤ºæ–‡å­—
                        contentElement = createElement(`<div class="message-bubbles"><div class="message-text"><span class="typing-indicator"><span></span><span></span><span></span></span></div></div>`);
                    } else if (st === 'empty') {
                        // æ— å†…å®¹æ—¶ä¸æ˜¾ç¤ºåŠ è½½æ–‡å­—
                        contentElement = createElement(`<div class="message-bubbles"><div class="message-text">Response No Message...</div></div>`);
                    } else {
                        contentElement = renderGroupedBubbles(msg.id, text);
                    }
                }
                const dataAgentAttr = (!isUser && agent) ? `data-agent-id="${agent.id}"` : '';
                
                const messageElement = createElement(`
                    <div class="message ${isUser ? 'user' : ''}" ${msg.id ? `data-msg-id="${msg.id}"` : ''}>
                        <div class="message-avatar" ${dataAgentAttr} style="background: ${color}">
                            ${name.charAt(0).toUpperCase()}
                        </div>
                        <div class="message-content">
                            <div class="message-header">
                                <span class="message-name">${name}</span>
                                <span class="message-time">${formatTime(msg.timestamp)}</span>
                                ${(!isUser && (msg.thinking && msg.thinking.trim())) ? `<button class=\"ms-think-toggle\" data-msg-id=\"${msg.id}\" aria-expanded=\"false\" title=\"æ˜¾ç¤º/éšè—æ€è€ƒè¿‡ç¨‹\">ğŸ§ <i class="think-blink" aria-hidden="true"></i></button>` : ''}
                                ${(!isUser && statusTag(msg)) ? `<span class=\"message-status\">${statusTag(msg)}${((progressing(msg.status)) && msg.id) ? ` <button class=\"ms-action\" data-action=\"cancel-msg\" data-msg-id=\"${msg.id}\" title=\"åœæ­¢\" aria-label=\"åœæ­¢\">â¹</button>` : ''}</span>` : ''}
                                <div class="message-tools" role="group" aria-label="æ¶ˆæ¯å·¥å…·">
                                    <button class="icon-btn" data-action="copy-msg" title="å¤åˆ¶" aria-label="å¤åˆ¶">ğŸ“‹</button>
                                    <button class="icon-btn" data-action="export-msg" title="å¯¼å‡ºä¸º Markdown" aria-label="å¯¼å‡º">â¬‡ï¸</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `);
                // æ’å…¥æ€è€ƒè¿‡ç¨‹å®¹å™¨ï¼ˆä½äº header ä¸ bubbles ä¹‹é—´ï¼Œä»…å½“å­˜åœ¨æ€è€ƒå†…å®¹ï¼‰
                if (!isUser && (msg.thinking && msg.thinking.trim())) {
                    const thinkEl = createElement(`<div class="message-thinking hidden"></div>`);
                    thinkEl.textContent = msg.thinking || '';
                    qs(`.message-content`, messageElement).appendChild(thinkEl);
                }
                qs(`.message-content`, messageElement).appendChild(contentElement);
                return messageElement;
            });

            fragment.append(...messageElements);
            el.chatMessages.innerHTML = '';
            el.chatMessages.appendChild(fragment);
            
            if (shouldAutoScroll) {
                el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
            }
            if (el.scrollToBottomBtn) {
                el.scrollToBottomBtn.classList.toggle('show', !isAtBottom(el.chatMessages));
            }
        }

        // å°†ä¸€æ®µæ–‡æœ¬æŒ‰â€œç©ºè¡Œåˆ†æ®µâ€ï¼Œä»£ç å— (``` ... ```) å†…ä¸æ‹†åˆ†
        function splitIntoParagraphs(text) {
            const lines = (text || '').replace(/\r\n/g, '\n').split('\n');
            const out = [];
            let buf = [];
            let inFence = false;
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.startsWith('```')) {
                    inFence = !inFence;
                    buf.push(line);
                    continue;
                }
                buf.push(line);
                if (!inFence && trimmed === '') {
                    out.push(buf.join('\n').trimEnd());
                    buf = [];
                }
            }
            if (buf.length) out.push(buf.join('\n').trimEnd());
            return out.filter(p => p.trim() !== '' && !/^[-]{2,}$/.test(p.trim()));
        }

        function renderGroupedBubbles(id, text) {
            const paras = splitIntoParagraphs(text);
            const bubbles = paras.map((p, index) => createMarkdownElement(`${id}_${index}`, p));
            const bubbleContainer = createElement(`<div class="message-bubbles"></div>`);
            if (bubbles.length === 0) {
                bubbleContainer.appendChild(createElement(`<div class="message-text">None(Bubble Container None...)</div>`));
            } else {
                bubbleContainer.append(...bubbles);
            }
            return bubbleContainer;
        }

        // å°†å¢é‡æ–‡æœ¬æŒ‰ <think>...</think> æ ‡ç­¾åˆ‡åˆ†ä¸ºâ€œæ€è€ƒå†…å®¹â€å’Œâ€œå¯è§å†…å®¹â€
        function splitThinkSegments(str, inThink) {
            let contentPart = '';
            let thinkingPart = '';
            let iThink = !!inThink;
            let i = 0;
            while (i < str.length) {
                if (iThink) {
                    const closeIdx = str.indexOf('</think>', i);
                    if (closeIdx === -1) {
                        thinkingPart += str.slice(i);
                        i = str.length;
                        break;
                    }
                    thinkingPart += str.slice(i, closeIdx);
                    i = closeIdx + 8; // len('</think>')
                    iThink = false;
                } else {
                    const openIdx = str.indexOf('<think>', i);
                    if (openIdx === -1) {
                        contentPart += str.slice(i);
                        i = str.length;
                        break;
                    }
                    contentPart += str.slice(i, openIdx);
                    i = openIdx + 7; // len('<think>')
                    iThink = true;
                }
            }
            return { contentPart, thinkingPart, inThinkAfter: iThink };
        }

        function selectGroup(groupId) {
            currentGroupId = groupId;
            const group = groups.find(g => g.id === groupId);
            
            if (!group) return;
            if (!group.agentSettings) group.agentSettings = {};

            // è®°ä½ä¸Šæ¬¡è¿›å…¥çš„ç¾¤èŠ
            localStorage.setItem('lastGroupId_v1', groupId);

            const groupAgents = group.agentIds.map(id => agents.find(a => a.id === id)).filter(a => a);
            
            el.currentGroupName.textContent = group.name + `(${groupAgents.length + 1})`;
            const participantNames = [globalSettings.userName, ...groupAgents.map(a => a.name)];
            el.groupAgents.textContent = `å‚ä¸è€…: ${participantNames.join(', ')}`;
            el.userInput.disabled = false;
            el.sendBtn.disabled = false;
            el.editGroupBtn.disabled = !!group.isAllAgentsGroup;
            el.clearChatBtn.disabled = false;
            updateSendBtnLabel();
            closeMention();
            
            shouldAutoScroll = true;

            renderGroups();
            renderMessages();
            renderAgents();
        }

        function openAgentModal() {
            currentEditingAgent = null;
            el.agentModalTitle.textContent = 'åˆ›å»ºè§’è‰²';
            el.agentForm.reset();
            el.agentColor.value = generateRandomColor();
            el.agentUseGlobal.checked = true;
            toggleAgentConfig();
            if (el.agentTTSUseGlobal) { el.agentTTSUseGlobal.checked = true; }
            toggleAgentTTSConfig();
            // åˆå§‹åŒ–æƒé™ï¼ˆä»…å½“å‰ç¾¤ï¼‰
            const group = groups.find(g => g.id === currentGroupId);
            if (group) {
                // æ–°å»ºæ—¶é»˜è®¤ all
                qsa('input[name="permSeeMode"]').forEach(r=>{ r.checked = (r.value==='all'); });
                qsa('input[name="permSeenMode"]').forEach(r=>{ r.checked = (r.value==='all'); });
                el.permICanSeeList.style.display = 'none';
                el.permCanSeeMeList.style.display = 'none';
                el.permVisionType.value = 'all';
                el.permVisionExpr.value = '';
                el.permVisionExprWrap.style.display = 'none';
                if (el.permVisionError) { el.permVisionError.style.display = 'none'; el.permVisionError.textContent=''; }
                // é¢„æ„å»ºç¾¤æˆå‘˜åˆ—è¡¨ï¼ˆåŒ…å«ç”¨æˆ·åœ¨é¦–ä½ï¼‰
                const members = [{ id: '__user__', name: globalSettings.userName, color: '#667eea' }]
                    .concat((group.agentIds||[]).map(id => agents.find(a=>a.id===id)).filter(Boolean));
                const buildList = (container) => {
                    container.innerHTML = members.map(m => `<div class="checkbox-item"><input type="checkbox" id="perm_${container.id}_${m.id}" value="${m.id}"><label for="perm_${container.id}_${m.id}" style="margin:0;"><span class="agent-color" style="background:${m.color||'#667eea'}"></span>${escapeHtml(m.name)}</label></div>`).join('');
                };
                buildList(el.permICanSeeList);
                buildList(el.permCanSeeMeList);
                // åˆ‡æ¢äº‹ä»¶ï¼ˆè‡ªå®šä¹‰æ—¶æ˜¾ç¤ºåˆ—è¡¨ï¼Œè‹¥ä¸ºç©ºåˆ™é‡å»ºï¼‰
                qsa('input[name="permSeeMode"]').forEach(r=>{ r.onchange = ()=>{ el.permICanSeeList.style.display = (r.value==='custom'&&r.checked)?'':'none'; if (el.permICanSeeList.innerHTML.trim()==='') buildList(el.permICanSeeList); }; });
                qsa('input[name="permSeenMode"]').forEach(r=>{ r.onchange = ()=>{ el.permCanSeeMeList.style.display = (r.value==='custom'&&r.checked)?'':'none'; if (el.permCanSeeMeList.innerHTML.trim()==='') buildList(el.permCanSeeMeList); }; });
            }
            el.agentModal.classList.add('active');
            resetModalScroll(el.agentModal);
        }

        function closeAgentModal() {
            el.agentModal.classList.remove('active');
        }

        function toggleAgentConfig(agentConfig) {
            const useGlobal = el.agentUseGlobal.checked;
            
            if (useGlobal) {
                el.agentConfigSection.classList.add('hidden');
            } else {
                el.agentConfigSection.classList.remove('hidden');
            }
            setAgentConfigPlaceholders(agentConfig);
        }

        function toggleAgentTTSConfig() {
            const useGlobal = el.agentTTSUseGlobal?.checked !== false;
            if (el.agentTTSConfigSection) {
                el.agentTTSConfigSection.classList.toggle('hidden', useGlobal);
            }
        }

        function editAgent(index) {
            currentEditingAgent = index;
            const agent = agents[index];
            el.agentModalTitle.textContent = 'ç¼–è¾‘è§’è‰²';
            el.agentName.value = agent.name;
            el.agentRole.value = agent.role || '';
            el.agentPrompt.value = agent.prompt;
            el.agentColor.value = agent.color;
            el.agentUseGlobal.checked = agent.useGlobal !== false;

            const agentConfig = resolveAgentConfig(agent, globalSettings);
            toggleAgentConfig(agentConfig);
            el.agentBaseUrl.value = agentConfig.baseUrl || '';
            el.agentApiKey.value = agentConfig.apiKey || '';
            el.agentModal.value = agentConfig.model || '';
            el.agentTemperature.value = agentConfig.temperature || 0.7;
            el.agentMaxTokens.value = agentConfig.maxTokens || 2000;

            // TTS
            if (el.agentTTSUseGlobal) el.agentTTSUseGlobal.checked = agent.ttsUseGlobal !== false;
            toggleAgentTTSConfig();
            const ttsCfg = resolveTTSConfig(agent, globalSettings);
            if (agent.ttsUseGlobal === false && agent.tts) {
                if (el.agentTTSBaseUrl) el.agentTTSBaseUrl.value = agent.tts.baseUrl || '';
                if (el.agentTTSApiKey) el.agentTTSApiKey.value = agent.tts.apiKey || '';
            } else {
                if (el.agentTTSBaseUrl) el.agentTTSBaseUrl.placeholder = ttsCfg.baseUrl || '';
                if (el.agentTTSApiKey) el.agentTTSApiKey.placeholder = 'ç•™ç©ºä»¥ä½¿ç”¨å…¨å±€ TTS API Key';
            }
            if (el.agentTTSVoice) el.agentTTSVoice.value = ttsCfg.voice || '';
            if (el.agentTTSStyle) el.agentTTSStyle.value = ttsCfg.style || '';
            if (el.agentTTSRate) el.agentTTSRate.value = ttsCfg.rate ?? 0;
            if (el.agentTTSPitch) el.agentTTSPitch.value = ttsCfg.pitch ?? 0;
            if (el.agentTTSFormat) el.agentTTSFormat.value = ttsCfg.format || '';

            // æƒé™ï¼ˆä»…å½“å‰ç¾¤ï¼‰
            const group = groups.find(g => g.id === currentGroupId);
            if (group) {
                const s = getAgentGroupSettings(group, agent.id);
                // members list
                const members = [{ id: '__user__', name: globalSettings.userName, color: '#667eea' }]
                    .concat((group.agentIds||[]).map(id => agents.find(a=>a.id===id)).filter(Boolean));
                const buildList = (container, selectedArr) => {
                    container.innerHTML = members.map(m => `<div class="checkbox-item"><input type="checkbox" id="perm_${container.id}_${m.id}" value="${m.id}" ${Array.isArray(selectedArr)&&selectedArr.includes(m.id)?'checked':''}><label for="perm_${container.id}_${m.id}" style="margin:0;"><span class="agent-color" style="background:${m.color||'#667eea'}"></span>${escapeHtml(m.name)}</label></div>`).join('');
                };
                // iCanSee
                const seeMode = (s.perspective?.iCanSee==='all')?'all':'custom';
                qsa('input[name=\"permSeeMode\"]').forEach(r=>{ r.checked = (r.value===seeMode); r.onchange = ()=>{ el.permICanSeeList.style.display = (r.value==='custom'&&r.checked)?'':'none'; if (el.permICanSeeList.innerHTML.trim()==='') buildList(el.permICanSeeList, []); }; });
                el.permICanSeeList.style.display = seeMode==='custom' ? '' : 'none';
                buildList(el.permICanSeeList, seeMode==='custom' ? (s.perspective?.iCanSee||[]) : []);
                // canSeeMe
                const seenMode = (s.perspective?.canSeeMe==='all')?'all':'custom';
                qsa('input[name=\"permSeenMode\"]').forEach(r=>{ r.checked = (r.value===seenMode); r.onchange = ()=>{ el.permCanSeeMeList.style.display = (r.value==='custom'&&r.checked)?'':'none'; if (el.permCanSeeMeList.innerHTML.trim()==='') buildList(el.permCanSeeMeList, []); }; });
                el.permCanSeeMeList.style.display = seenMode==='custom' ? '' : 'none';
                buildList(el.permCanSeeMeList, seenMode==='custom' ? (s.perspective?.canSeeMe||[]) : []);
                // vision
                const v = s.vision || { type:'all' };
                el.permVisionType.value = v.type || 'all';
                el.permVisionExpr.value = v.expr || '';
                el.permVisionExprWrap.style.display = (v.type==='custom') ? '' : 'none';
                if (el.permVisionError) { el.permVisionError.style.display = 'none'; el.permVisionError.textContent = ''; }
            }
            el.agentModal.classList.add('active');
            resetModalScroll(el.agentModal);
        }

        function saveAgent() {
            const useGlobal = el.agentUseGlobal.checked;
            const isEdit = currentEditingAgent !== null;
            
            const agent = {
                id: currentEditingAgent !== null ? agents[currentEditingAgent].id : generateId(),
                name: el.agentName.value,
                role: el.agentRole.value,
                prompt: el.agentPrompt.value,
                color: el.agentColor.value,
                useGlobal: useGlobal,
                model: el.agentModel.value || globalSettings.model
            };

            if (!useGlobal) {
                if (el.agentBaseUrl.value) agent.baseUrl = el.agentBaseUrl.value;
                if (el.agentApiKey.value) agent.apiKey = el.agentApiKey.value;
                if (el.agentTemperature.value !== '') agent.temperature = parseFloat(el.agentTemperature.value);
                if (el.agentMaxTokens.value !== '') agent.maxTokens = parseInt(el.agentMaxTokens.value);
            }

            // TTS per-agent
            agent.ttsUseGlobal = el.agentTTSUseGlobal?.checked !== false;
            if (agent.ttsUseGlobal === false) {
                agent.tts = agent.tts || {};
                if (el.agentTTSBaseUrl?.value) agent.tts.baseUrl = el.agentTTSBaseUrl.value;
                if (el.agentTTSApiKey?.value) agent.tts.apiKey = el.agentTTSApiKey.value;
                if (el.agentTTSVoice?.value) agent.tts.voice = el.agentTTSVoice.value;
                if (el.agentTTSStyle?.value) agent.tts.style = el.agentTTSStyle.value;
                if (el.agentTTSRate?.value !== '') agent.tts.rate = parseInt(el.agentTTSRate.value||'0',10)||0;
                if (el.agentTTSPitch?.value !== '') agent.tts.pitch = parseInt(el.agentTTSPitch.value||'0',10)||0;
                if (el.agentTTSFormat?.value) agent.tts.format = el.agentTTSFormat.value;
            } else {
                delete agent.tts;
            }

            if (currentEditingAgent !== null) {
                agents[currentEditingAgent] = agent;
            } else {
                agents.push(agent);
                const allGroup = groups.find(g => g.isAllAgentsGroup);
                if (allGroup) {
                    if (!Array.isArray(allGroup.agentIds)) allGroup.agentIds = [];
                    if (!allGroup.agentIds.includes(agent.id)) allGroup.agentIds.push(agent.id);
                }
                if (currentGroupId) {
                    const curr = groups.find(g => g.id === currentGroupId);
                    if (curr) {
                        if (!Array.isArray(curr.agentIds)) curr.agentIds = [];
                        if (!curr.agentIds.includes(agent.id)) curr.agentIds.push(agent.id);
                    }
                }
            }

            ensureAllAgentsGroup();
            saveData();
            renderAgents();
            renderGroups();
            // ä¿å­˜æƒé™åˆ°å½“å‰ç¾¤
            if (currentGroupId) {
                const group = groups.find(g => g.id === currentGroupId);
                if (group) {
                    const s = getAgentGroupSettings(group, agent.id);
                    const seeMode = (qsa('input[name="permSeeMode"]').find(r=>r.checked)?.value)||'all';
                    const seenMode = (qsa('input[name="permSeenMode"]').find(r=>r.checked)?.value)||'all';
                    if (seeMode==='all') s.perspective.iCanSee='all';
                    else s.perspective.iCanSee = Array.from(el.permICanSeeList.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value);
                    if (seenMode==='all') s.perspective.canSeeMe='all';
                    else s.perspective.canSeeMe = Array.from(el.permCanSeeMeList.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value);
                    const vt = el.permVisionType.value || 'all';
                    if (vt==='custom') {
                        const err = validatePermVisionExprLive();
                        if (err) { showToast('è‡ªå®šä¹‰è§†é‡è§„åˆ™æ— æ•ˆï¼š'+err, 'warning'); return; }
                        s.vision.type = 'custom'; s.vision.expr = el.permVisionExpr.value || '';
                    } else if (vt==='last1') { s.vision.type='last1'; s.vision.expr=''; }
                    else { s.vision.type='all'; s.vision.expr=''; }
                    saveData();
                }
            }
            if (currentGroupId) renderMessages();
            showToast(isEdit ? 'ä¿å­˜æˆåŠŸ' : 'åˆ›å»ºæˆåŠŸ', 'success');
            closeAgentModal();
        }

        function deleteAgent(index) {
            const removed = agents[index];
            if (!removed) return;
            const agentId = removed.id;
            const originalIndex = index;
            const affectedGroups = groups
                .filter(g => Array.isArray(g.agentIds) && g.agentIds.includes(agentId))
                .map(g => g.id);

            agents.splice(index, 1);
            groups.forEach(group => {
                group.agentIds = (group.agentIds || []).filter(id => id !== agentId);
            });

            saveData();
            renderAgents();
            renderGroups();
            if (currentGroupId) renderMessages();

            let undone = false;
            const undo = () => {
                if (undone) return; undone = true;
                const insertAt = Math.min(originalIndex, agents.length);
                agents.splice(insertAt, 0, removed);
                groups.forEach(group => {
                    if (affectedGroups.includes(group.id)) {
                        if (!group.agentIds) group.agentIds = [];
                        if (!group.agentIds.includes(agentId)) group.agentIds.push(agentId);
                    }
                });
                saveData();
                renderAgents();
                renderGroups();
                if (currentGroupId) renderMessages();
                showToast('å·²æ’¤é”€åˆ é™¤', 'info', 3000);
            };

            showToast('åˆ é™¤æˆåŠŸ', 'success', 6000, { text: 'æ’¤é”€', onClick: undo });
        }

        function removeAgentFromCurrentGroup(agentId) {
            if (!currentGroupId) return;
            const group = groups.find(g => g.id === currentGroupId);
            if (!group) return;
            if (!Array.isArray(group.agentIds)) group.agentIds = [];
            if (!group.agentIds.includes(agentId)) return;

            const prev = group.agentIds.slice();
            group.agentIds = group.agentIds.filter(id => id !== agentId);
            saveData();
            renderAgents();
            renderGroups();
            if (currentGroupId) renderMessages();

            let undone = false;
            const undo = () => {
                if (undone) return; undone = true;
                group.agentIds = prev;
                saveData();
                renderAgents();
                renderGroups();
                if (currentGroupId) renderMessages();
                showToast('å·²æ’¤é”€ç§»é™¤', 'info', 3000);
            };
            showToast('å·²ä»å½“å‰ç¾¤èŠç§»é™¤', 'success', 6000, { text: 'æ’¤é”€', onClick: undo });
        }

        function openGroupModal() {
            if (agents.length === 0) {
                showToast('è¯·å…ˆåˆ›å»ºè‡³å°‘ä¸€ä¸ªè§’è‰²', 'warning');
                return;
            }

            currentEditingGroup = null;
            el.groupModalTitle.textContent = 'åˆ›å»ºç¾¤èŠ';
            el.groupForm.reset();
            el.groupAutoReply.checked = true;
            el.groupMaxRounds.value = '5';
            if (el.groupAutoReplyMode) el.groupAutoReplyMode.value = 'round_robin';
            if (el.groupSelectorModel) {
                updateSelectorModelSelect();
                el.groupSelectorModel.value = globalSettings.model || '';
            }
            renderAgentCheckboxes();
            updateGroupAutoReplyUI();
            el.groupModal.classList.add('active');
            resetModalScroll(el.groupModal);
        }

        function closeGroupModal() {
            el.groupModal.classList.remove('active');
        }

        function editCurrentGroup() {
            if (!currentGroupId) return;
            const index = groups.findIndex(g => g.id === currentGroupId);
            if (index !== -1 && !groups[index].isAllAgentsGroup) editGroup(index);
        }

        function editGroup(index) {
            currentEditingGroup = index;
            const group = groups[index];
            el.groupModalTitle.textContent = 'ç¼–è¾‘ç¾¤èŠ';
            el.groupName.value = group.name;
            el.groupDesc.value = group.desc || '';
            el.groupAutoReply.checked = group.autoReply;
            el.groupMaxRounds.value = (group.maxRounds ?? 5);
            if (el.groupAutoReplyMode) el.groupAutoReplyMode.value = group.autoReplyMode || 'round_robin';
            if (el.groupSelectorModel) {
                updateSelectorModelSelect();
                el.groupSelectorModel.value = group.selectorModel || globalSettings.model || '';
                if (el.groupSelectorModel.value !== (group.selectorModel || globalSettings.model || '')) {
                    const opt = document.createElement('option');
                    opt.value = group.selectorModel || globalSettings.model || '';
                    opt.textContent = group.selectorModel || globalSettings.model || '';
                    el.groupSelectorModel.appendChild(opt);
                    el.groupSelectorModel.value = group.selectorModel || globalSettings.model || '';
                }
            }
            renderAgentCheckboxes(group.agentIds);
            updateGroupAutoReplyUI();
            el.groupModal.classList.add('active');
            resetModalScroll(el.groupModal);
        }

        function renderAgentCheckboxes(selectedIds = []) {
            el.agentCheckboxList.innerHTML = agents.map(agent => `
                <div class="checkbox-item">
                    <input type="checkbox" id="agent_${agent.id}" value="${agent.id}" 
                        ${selectedIds.includes(agent.id) ? 'checked' : ''}>
                    <label for="agent_${agent.id}" style="margin-bottom: 0;">
                        <span class="agent-color" style="background: ${agent.color}"></span>
                        ${agent.name} | ${agent.role || 'No Role'}
                    </label>
                </div>
            `).join('');
        }

        function saveGroup() {
            const selectedAgentIds = Array.from(qsa('#agentCheckboxList input:checked'))
                .map(input => input.value);

            if (selectedAgentIds.length === 0) {
                showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè§’è‰²', 'warning');
                return;
            }

            const group = {
                id: currentEditingGroup !== null ? groups[currentEditingGroup].id : generateId(),
                name: el.groupName.value,
                desc: el.groupDesc.value,
                agentIds: selectedAgentIds,
                autoReply: el.groupAutoReply.checked,
                autoReplyMode: el.groupAutoReplyMode ? el.groupAutoReplyMode.value : 'round_robin',
                maxRounds: parseInt(el.groupMaxRounds.value),
                selectorModel: (el.groupAutoReplyMode && el.groupAutoReplyMode.value === 'ai_selector') ? (el.groupSelectorModel?.value || '') : (groups[currentEditingGroup]?.selectorModel || ''),
                messages: currentEditingGroup !== null ? groups[currentEditingGroup].messages : []
            };

            const isEdit = currentEditingGroup !== null;
            if (isEdit) {
                groups[currentEditingGroup] = group;
            } else {
                groups.push(group);
            }

            saveData();
            renderGroups();
            autoSelectFirstGroupIfNone();
            // æ–°å»ºç¾¤èŠåï¼Œé»˜è®¤åˆ‡æ¢åˆ°è¯¥ç¾¤èŠ
            if (!isEdit) {
                selectGroup(group.id);
            } else if (currentGroupId === group.id) {
                selectGroup(group.id);
            }
            showToast(isEdit ? 'ä¿å­˜æˆåŠŸ' : 'åˆ›å»ºæˆåŠŸ', 'success');
            closeGroupModal();
        }

        function deleteGroup(index) {
            const removed = groups[index];
            if (!removed) return;
            const groupId = removed.id;
            const originalIndex = index;
            const wasCurrent = currentGroupId === groupId;
            const hadLast = localStorage.getItem('lastGroupId_v1') === groupId;

            groups.splice(index, 1);

            if (wasCurrent) {
                currentGroupId = null;
                el.currentGroupName.textContent = 'é€‰æ‹©ä¸€ä¸ªç¾¤èŠå¼€å§‹å¯¹è¯';
                el.groupAgents.textContent = '';
                el.userInput.disabled = true;
                el.sendBtn.disabled = true;
                el.editGroupBtn.disabled = true;
                el.clearChatBtn.disabled = true;
                el.chatMessages.innerHTML = '<div class="empty-state"><p>ğŸ‘ˆ ä»å·¦ä¾§é€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªç¾¤èŠ</p></div>';
            }

            if (hadLast) {
                localStorage.removeItem('lastGroupId_v1');
            }

            saveData();
            renderGroups();
            autoSelectFirstGroupIfNone();

            let undone = false;
            const undo = () => {
                if (undone) return; undone = true;
                const insertAt = Math.min(originalIndex, groups.length);
                groups.splice(insertAt, 0, removed);
                saveData();
                renderGroups();
                autoSelectFirstGroupIfNone();
                if (wasCurrent) {
                    currentGroupId = groupId;
                    selectGroup(groupId);
                }
                if (hadLast) {
                    localStorage.setItem('lastGroupId_v1', groupId);
                }
                showToast('å·²æ’¤é”€åˆ é™¤', 'info', 3000);
            };

            showToast('åˆ é™¤æˆåŠŸ', 'success', 6000, { text: 'æ’¤é”€', onClick: undo });
        }

        async function sendMessage() {
            const content = el.userInput.value.trim();
            if (!currentGroupId) return;
            if (!content) {
                const group = groups.find(g => g.id === currentGroupId);
                if (!group || group.isAllAgentsGroup) return;
                if (group.autoReply) {
                    const mode = group.autoReplyMode || 'round_robin';
                    if (mode === 'round_robin') {
                        await startGroupChatRoundRobin(group);
                    } else if (mode === 'random') {
                        await startGroupChatRandom(group);
                    } else {
                        await startGroupChatAISelector(group);
                    }
                } else {
                    const groupAgents = group.agentIds.map(id => agents.find(a => a.id === id)).filter(a => a);
                    if (groupAgents.length > 0) {
                        await getAgentResponse(group, groupAgents[0]);
                    }
                }
                return;
            }
            
            const group = groups.find(g => g.id === currentGroupId);
            if (!group) return;

            const userMessage = {
                id: generateId(),
                role: 'user',
                content: content,
                timestamp: Date.now()
            };

            if (!group.messages) group.messages = [];
            group.messages.push(userMessage);
            el.userInput.value = '';
            saveData();
            // å‘é€æ—¶å¼ºåˆ¶ç½®åº•
            shouldAutoScroll = true;
            renderMessages();
            scrollToBottom(true);

            if (group.isAllAgentsGroup) {
                return;
            }

            if (group.autoReply) {
                const mode = group.autoReplyMode || 'round_robin';
                if (mode === 'round_robin') {
                    await startGroupChatRoundRobin(group);
                } else if (mode === 'random') {
                    await startGroupChatRandom(group);
                } else {
                    await startGroupChatAISelector(group);
                }
            } else {
                const groupAgents = group.agentIds.map(id => agents.find(a => a.id === id)).filter(a => a);
                if (groupAgents.length > 0) {
                    await getAgentResponse(group, groupAgents[0]);
                }
            }
        }

        // --- Send button text ---
        function updateSendBtnLabel() {
            if (!el.sendBtn) return;
            const hasText = (el.userInput?.value || '').trim().length > 0;
            el.sendBtn.textContent = hasText ? 'å‘é€' : 'ç»§ç»­';
        }

        // --- Mention (@) ---
        let mentionState = { open: false, start: -1, query: '', items: [], filtered: [], selected: 0 };
        function getCurrentMentionContext() {
            const ta = el.userInput; if (!ta) return null;
            const pos = ta.selectionStart || 0;
            const text = ta.value || '';
            const head = text.slice(0, pos);
            const at = head.lastIndexOf('@');
            if (at === -1) return null;
            const segment = head.slice(at + 1);
            if (/\s|\n|\t/.test(segment)) return null;
            return { start: at, query: segment };
        }
        function updateMention() {
            const ctx = getCurrentMentionContext();
            if (!currentGroupId || !ctx) { closeMention(); return; }
            const group = groups.find(g => g.id === currentGroupId);
            if (!group) { closeMention(); return; }
            const list = group.agentIds.map(id => agents.find(a => a.id === id)).filter(Boolean);
            const q = (ctx.query || '').toLowerCase();
            const filtered = list.filter(a => a.name.toLowerCase().includes(q) || (a.role||'').toLowerCase().includes(q));
            if (filtered.length === 0) { closeMention(); return; }
            mentionState.open = true; mentionState.start = ctx.start; mentionState.query = ctx.query; mentionState.items = list; mentionState.filtered = filtered; mentionState.selected = 0;
            renderMentionMenu();
        }
        function renderMentionMenu() {
            if (!el.mentionMenu) return;
            el.mentionMenu.innerHTML = mentionState.filtered.map((a, i) => `
                <div class="mention-item ${i===mentionState.selected?'active':''}" data-index="${i}">
                    <span class="agent-color" style="width:16px;height:16px;border-radius:50%;background:${a.color}"></span>
                    <span class="mention-name">${a.name}</span>
                    ${a.role ? `<span class="mention-role">${a.role}</span>` : ''}
                </div>
            `).join('');
            el.mentionMenu.style.display = 'block';
            positionMentionMenu();
            scrollActiveMentionIntoView();
        }
        function closeMention() {
            mentionState.open = false; mentionState.start = -1; mentionState.query = ''; mentionState.filtered = []; mentionState.selected = 0;
            if (el.mentionMenu) { el.mentionMenu.style.display = 'none'; el.mentionMenu.innerHTML = ''; }
        }
        function moveMention(delta) {
            if (!mentionState.open || mentionState.filtered.length === 0) return;
            const n = mentionState.filtered.length;
            mentionState.selected = (mentionState.selected + delta + n) % n;
            renderMentionMenu();
            scrollActiveMentionIntoView();
        }
        function chooseMention() {
            if (!mentionState.open || mentionState.filtered.length === 0) { closeMention(); return; }
            const ta = el.userInput; const pos = ta.selectionStart || 0; const start = mentionState.start;
            const chosen = mentionState.filtered[mentionState.selected]; if (!chosen) { closeMention(); return; }
            const before = ta.value.slice(0, start);
            const after = ta.value.slice(pos);
            const insert = '@' + chosen.name + ' ';
            ta.value = before + insert + after;
            const newPos = (before + insert).length;
            ta.setSelectionRange(newPos, newPos);
            ta.focus();
            updateSendBtnLabel();
            closeMention();
        }

        function positionMentionMenu() {
            if (!el.mentionMenu || !el.userInput || !mentionState.open) return;
            try {
                const ta = el.userInput;
                const caret = getTextareaCaretPosition(ta);
                const container = ta.parentElement; // .chat-input
                const containerRect = container.getBoundingClientRect();
                let left = caret.left - containerRect.left;

                // Prepare to measure menu size
                el.mentionMenu.style.left = '0px';
                el.mentionMenu.style.top = '0px';
                el.mentionMenu.style.display = 'block';
                const menuRect = el.mentionMenu.getBoundingClientRect();

                // Decide above/below by viewport space at caret
                const viewportBottomSpace = window.innerHeight - caret.top;
                const shouldPlaceBelow = viewportBottomSpace >= (menuRect.height + 12);
                let top = shouldPlaceBelow
                    ? (caret.top - containerRect.top + caret.lineHeight + 6)
                    : (caret.top - containerRect.top - menuRect.height - 6);

                // Constrain horizontally within container
                const maxLeft = containerRect.width - menuRect.width - 8;
                left = Math.max(8, Math.min(left, Math.max(8, maxLeft)));

                // Allow negative top so the menu can render above the chat-input when needed
                // But avoid going off the very top of the viewport
                const absoluteTop = top + containerRect.top; // viewport coords
                const minViewportTop = 8;
                if (absoluteTop < minViewportTop) {
                    const delta = minViewportTop - absoluteTop;
                    top += delta;
                }

                el.mentionMenu.style.left = `${left}px`;
                el.mentionMenu.style.top = `${top}px`;
            } catch (_) {
                // Fallback position
                el.mentionMenu.style.left = '16px';
                el.mentionMenu.style.top = '-8px';
            }
        }

        function getTextareaCaretPosition(ta) {
            const pos = ta.selectionStart || 0;
            const cs = window.getComputedStyle(ta);
            const div = document.createElement('div');
            const span = document.createElement('span');
            // Mirror essential styles
            const props = [
                'boxSizing','width','paddingTop','paddingRight','paddingBottom','paddingLeft',
                'borderTopWidth','borderRightWidth','borderBottomWidth','borderLeftWidth',
                'fontFamily','fontSize','fontWeight','fontStyle','letterSpacing','textTransform','textAlign','lineHeight','tabSize'
            ];
            div.style.position = 'absolute';
            div.style.visibility = 'hidden';
            div.style.zIndex = '-9999';
            div.style.whiteSpace = 'pre-wrap';
            div.style.wordWrap = 'break-word';
            props.forEach(p => { div.style[p] = cs[p]; });
            div.style.width = ta.clientWidth + 'px';
            // Mirror content up to caret
            const before = (ta.value || '').substring(0, pos).replace(/\n/g, '\n');
            div.textContent = before;
            span.textContent = '\u200b';
            div.appendChild(span);
            document.body.appendChild(div);
            const spanRect = span.getBoundingClientRect();
            const divRect = div.getBoundingClientRect();
            const taRect = ta.getBoundingClientRect();
            const left = taRect.left + (spanRect.left - divRect.left) - ta.scrollLeft + window.scrollX;
            const top = taRect.top + (spanRect.top - divRect.top) - ta.scrollTop + window.scrollY;
            const lineHeight = parseFloat(cs.lineHeight) || 18;
            document.body.removeChild(div);
            return { left, top, lineHeight };
        }

        function scrollActiveMentionIntoView() {
            const menu = el.mentionMenu; if (!menu) return;
            const active = menu.querySelector('.mention-item.active'); if (!active) return;
            const itemTop = active.offsetTop;
            const itemBottom = itemTop + active.offsetHeight;
            const viewTop = menu.scrollTop;
            const viewBottom = viewTop + menu.clientHeight;
            if (itemTop < viewTop) {
                menu.scrollTop = itemTop;
            } else if (itemBottom > viewBottom) {
                menu.scrollTop = itemBottom - menu.clientHeight;
            }
        }

        async function startGroupChatRoundRobin(group) {
            let rounds = 0;
            const maxRounds = group.maxRounds || 0;
            const groupAgents = group.agentIds.map(id => agents.find(a => a.id === id)).filter(a => a);

            while (rounds < maxRounds && groupAgents.length > 0) {
                const agentIndex = rounds % groupAgents.length;
                const agent = groupAgents[agentIndex];
                
                await getAgentResponse(group, agent);
                rounds++;

                if (rounds < maxRounds) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        async function startGroupChatRandom(group) {
            const maxRounds = group.maxRounds || 0;
            const groupAgents = group.agentIds.map(id => agents.find(a => a.id === id)).filter(a => a);
            if (groupAgents.length === 0) return;
            // éšæœºå†³å®šæœ¬è½®ä¼šè¿›è¡Œçš„å›å¤æ¬¡æ•°ï¼ˆä¸Šé™ä¸º maxRoundsï¼Œè‡³å°‘ 1 æ¬¡ï¼‰
            const totalRounds = Math.max(1, Math.floor(Math.random() * Math.max(1, maxRounds)) + 1);
            let lastAgentId = null;
            for (let i = 0; i < totalRounds; i++) {
                let candidate;
                // å°½é‡é¿å…è¿ç»­åŒä¸€è§’è‰²
                const pool = groupAgents.filter(a => a.id !== lastAgentId);
                if (pool.length === 0) {
                    candidate = groupAgents[Math.floor(Math.random() * groupAgents.length)];
                } else {
                    candidate = pool[Math.floor(Math.random() * pool.length)];
                }
                await getAgentResponse(group, candidate);
                lastAgentId = candidate.id;
                if (i < totalRounds - 1) {
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
        }

        async function startGroupChatAISelector(group) {
            const candidates = group.agentIds.map(id => agents.find(a => a.id === id)).filter(a => a);
            if (candidates.length === 0) return;
            const MAX_STEPS = Math.max(1, group.maxRounds || 20); // å®‰å…¨ä¸Šé™ç”±ç”¨æˆ·é…ç½®å†³å®š
            for (let step = 0; step < MAX_STEPS; step++) {
                const next = await selectNextAgentByAI(group, candidates);
                if (!next || next === 'STOP') {
                    addSystemMessage(group, 'AI å†³å®šç»“æŸå¯¹è¯', 'info');
                    break;
                }
                addSystemMessage(group, `AI é€‰æ‹©ç”± ${next.name} å›å¤`, 'info');
                await getAgentResponse(group, next);
                if (step < MAX_STEPS - 1) {
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
        }

        async function selectNextAgentByAI(group, candidates) {
            try {
                if (!globalSettings.apiKey || !globalSettings.baseUrl) {
                    showToast('è¯·å…ˆåœ¨ç”¨æˆ·è®¾ç½®ä¸­é…ç½® API Key å’Œ Base URL', 'warning');
                    return null;
                }
                const client = await getOpenAIClient(globalSettings);
                const candidateList = candidates.map(a => ({ name: a.name, role: a.role || '' }));
                const recent = (group.messages || []).slice(-10).filter(m => m.role !== 'system');
                const history = recent.map(m => {
                    if (m.role === 'user') return { role: 'user', content: `[${globalSettings.userName}]: ${m.content}` };
                    const msgAgent = agents.find(a => a.id === m.agentId);
                    const name = msgAgent ? msgAgent.name : 'æœªçŸ¥';
                    return { role: 'user', content: `[${name}]: ${m.content}` };
                });
                const sys = {
                    role: 'system',
                    content: `ä½ æ˜¯ç¾¤èŠçš„ä¸»æŒä¸è°ƒåº¦è€…ã€‚è¯·æ ¹æ®æœ€è¿‘å¯¹è¯å†å²ï¼Œä»å€™é€‰äººä¸­é€‰æ‹©ä¸‹ä¸€ä½å‘è¨€è€…ï¼Œæˆ–å†³å®šç»“æŸã€‚
ä¸¥æ ¼éµå¾ªè¾“å‡ºæ ¼å¼ï¼Œåªèƒ½è¾“å‡ºä¸¥æ ¼ JSONï¼ˆä¸åŒ…å«å¤šä½™æ–‡æœ¬/è§£é‡Š/ä»£ç å—æ ‡è®°ï¼‰ï¼š{"next":"<å€™é€‰åç§°>"} æˆ– {"next":"STOP"}ã€‚
å€™é€‰äººåˆ—è¡¨ï¼ˆä»…å¯ä»è¿™äº›åç§°ä¸­é€‰æ‹©ï¼‰ï¼š${JSON.stringify(candidateList)}ã€‚`
                };
                const resp = await client.chat.completions.create({
                    model: (groups.find(g=>g.id===group.id)?.selectorModel) || group.selectorModel || globalSettings.model || 'gpt-3.5-turbo',
                    temperature: 0.2,
                    max_tokens: 60,
                    messages: [sys, ...history]
                });
                const textRaw = resp.choices?.[0]?.message?.content || '';
                const text = textRaw.trim();
                let jsonStr = text;
                if (!jsonStr.startsWith('{')) {
                    const first = text.indexOf('{');
                    const last = text.lastIndexOf('}');
                    if (first !== -1 && last !== -1 && last > first) {
                        jsonStr = text.substring(first, last + 1);
                    }
                }
                let obj;
                try { obj = JSON.parse(jsonStr); } catch { return null; }
                const nextName = obj && typeof obj.next === 'string' ? obj.next : null;
                if (nextName === 'STOP') return 'STOP';
                const found = candidates.find(a => a.name === nextName);
                return found || null;
            } catch (e) {
                console.error('AI é€‰æ‹©å™¨å¤±è´¥:', e);
                addSystemMessage(group, 'AI é€‰æ‹©å™¨å¤±è´¥ï¼š' + (e.message || 'æœªçŸ¥é”™è¯¯'), 'warning');
                return null;
            }
        }

        function updateGroupAutoReplyUI() {
            const enabled = el.groupAutoReply?.checked;
            if (el.groupAutoReplyModeWrap) {
                el.groupAutoReplyModeWrap.style.display = enabled ? '' : 'none';
            }
            const mode = el.groupAutoReplyMode ? el.groupAutoReplyMode.value : 'round_robin';
            if (el.groupMaxRoundsWrap) {
                const showRounds = enabled; // æ‰€æœ‰æ¨¡å¼ä¸‹å‡æ˜¾ç¤ºï¼Œä½œä¸ºå®‰å…¨ä¸Šé™
                el.groupMaxRoundsWrap.style.display = showRounds ? '' : 'none';
            }
            if (el.groupSelectorModelWrap) {
                const showSelector = enabled && mode === 'ai_selector';
                el.groupSelectorModelWrap.style.display = showSelector ? '' : 'none';
            }
        }

        function updateSelectorModelSelect() {
            if (!el.groupSelectorModel) return;
            const models = (globalSettings.models && globalSettings.models.length > 0)
                ? globalSettings.models
                : [
                    '', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo', 'gpt-3.5-turbo-16k',
                    'claude-3-opus', 'claude-3-sonnet', 'claude-3-haiku'
                  ];
            if (models[0] === '') {
                el.groupSelectorModel.innerHTML = [
                    '<option value="">-- é€‰æ‹©æ¨¡å‹æˆ–ç‚¹å‡»åˆ·æ–° --</option>',
                    '<option value="gpt-4-turbo">gpt-4-turbo</option>',
                    '<option value="gpt-4">gpt-4</option>',
                    '<option value="gpt-3.5-turbo">gpt-3.5-turbo</option>',
                    '<option value="gpt-3.5-turbo-16k">gpt-3.5-turbo-16k</option>',
                    '<option value="claude-3-opus">claude-3-opus</option>',
                    '<option value="claude-3-sonnet">claude-3-sonnet</option>',
                    '<option value="claude-3-haiku">claude-3-haiku</option>'
                ].join('');
            } else {
                el.groupSelectorModel.innerHTML = models.map(m=>`<option value="${m}">${m}</option>`).join('');
            }
        }

        async function loadSelectorModels(e) {
            if (!globalSettings.apiKey || !globalSettings.baseUrl) {
                showToast('è¯·å…ˆé…ç½® API Key å’Œ Base URL', 'warning');
                return;
            }
            try {
                const btn = e ? e.target : el.groupSelectorRefreshModelsBtn;
                if (btn) { btn.disabled = true; btn.innerHTML = '<div class="loading-spinner"></div>'; }
                const client = await getOpenAIClient(globalSettings);
                const response = await client.models.list();
                const models = response.data.map(m=>m.id).sort((a,b)=>a.localeCompare(b));
                globalSettings.models = models;
                saveData();
                updateSelectorModelSelect();
                if (btn) { btn.disabled = false; btn.textContent = 'åˆ·æ–°'; }
                showToast(`æˆåŠŸåŠ è½½ ${models.length} ä¸ªæ¨¡å‹`, 'success');
            } catch (error) {
                const btn = e ? e.target : el.groupSelectorRefreshModelsBtn;
                if (btn) { btn.disabled = false; btn.textContent = 'åˆ·æ–°'; }
                showToast('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥: ' + error.message, 'error');
            }
        }

        async function getAgentResponse(group, agent) {
            try {
                const config = resolveAgentConfig(agent, globalSettings);
                const conversationHistory = buildHistoryForAgentInGroup(agent, group);

                const msgId = generateId();
                const assistantMessage = {
                    id: msgId,
                    role: 'assistant',
                    agentId: agent.id,
                    content: '',
                    timestamp: Date.now(),
                    status: 'loading',
                    thinking: ''
                };
                // å¯è§æ€§ï¼šè°èƒ½çœ‹è§æˆ‘ï¼ˆä»…é™æœ¬ç¾¤ï¼‰
                const ctx = getAgentGroupSettings(group, agent.id);
                const canSeeMe = (ctx.perspective?.canSeeMe ?? 'all');
                if (canSeeMe === 'all') {
                    assistantMessage.visibleToAgentIds = 'all';
                } else {
                    const allow = new Set((Array.isArray(canSeeMe) ? canSeeMe : []).filter(id => (group.agentIds||[]).includes(id)));
                    allow.add(agent.id);
                    assistantMessage.visibleToAgentIds = Array.from(allow);
                }
                group.messages.push(assistantMessage);
                const msgIndex = group.messages.length - 1;
                saveData();
                renderMessages();

                const client = await getOpenAIClient(config);
                const ac = new AbortController();
                inflight.set(msgId, { ac, inThink: false });
                const stream = await client.chat.completions.create({
                    model: config.model,
                    messages: conversationHistory,
                    temperature: config.temperature || 0.7,
                    max_tokens: config.maxTokens || 2000,
                    stream: true
                }, { signal: ac.signal });
                try { if (stream && stream.controller) {
                    const prev = inflight.get(msgId) || { ac };
                    inflight.set(msgId, { ...prev, stream });
                } } catch (_) {}

                for await (const chunk of stream) {
                    const d = chunk.choices?.[0]?.delta || {};
                    let raw = d.content || '';
                    // å…¼å®¹å¯èƒ½çš„ reasoning å­—æ®µ
                    let extraReason = '';
                    if (typeof d.reasoning === 'string') extraReason += d.reasoning;
                    if (Array.isArray(d.reasoning_content)) {
                        for (const it of d.reasoning_content) {
                            if (typeof it === 'string') extraReason += it;
                            else if (it && typeof it.text === 'string') extraReason += it.text;
                            else if (it && typeof it.content === 'string') extraReason += it.content;
                        }
                    } else if (typeof d.reasoning_content === 'string') {
                        extraReason += d.reasoning_content;
                    }

                    const info = inflight.get(msgId) || { ac };
                    const parts = splitThinkSegments(raw, !!info.inThink);
                    // ç´¯åŠ æ€è€ƒå†…å®¹ï¼ˆåŒ…å«é¢å¤– reasoningï¼‰
                    let thinkingDelta = parts.thinkingPart + (extraReason || '');
                    let hasThinkingAppend = false;
                    if (thinkingDelta) {
                        const prevThinking = group.messages[msgIndex]?.thinking || '';
                        group.messages[msgIndex].thinking = prevThinking + thinkingDelta;
                        hasThinkingAppend = true;
                    }
                    // çŠ¶æ€è¿ç§»
                    let visibleDelta = parts.contentPart;
                    const msgRef = group.messages[msgIndex];
                    if (msgRef && msgRef.status === 'loading') {
                        if (visibleDelta) {
                            msgRef.status = 'streaming';
                        } else if (thinkingDelta) {
                            msgRef.status = 'thinking';
                        }
                    } else if (msgRef && msgRef.status === 'thinking') {
                        if (visibleDelta) msgRef.status = 'streaming';
                    }
                    if (visibleDelta) {
                        let content = msgRef?.content ?? '';
                        if (content === '') {
                            visibleDelta = visibleDelta.trimStart();
                        }
                        content += visibleDelta;
                        msgRef.content = stripRoleNamePrefix(content);
                    }

                    inflight.set(msgId, { ...info, inThink: parts.inThinkAfter });
                    if (thinkingDelta || visibleDelta) {
                        renderMessages();
                    }
                }
                inflight.delete(msgId);
                const finalText = (group.messages[msgIndex]?.content || '').trim();
                group.messages[msgIndex].status = finalText ? 'done' : 'empty';
                saveData();
                renderMessages();
                if (!finalText) {
                    addSystemMessage(group, `è§’è‰² ${agent.name} ç©ºå›å¤`, 'info');
                }

            } catch (error) {
                console.error('Error:', error);
                // æŸ¥æ‰¾æœ€åä¸€æ¡é’ˆå¯¹è¯¥ agent çš„æµå¼æ¶ˆæ¯
                const groupRef = groups.find(g => g.id === group.id);
                const last = groupRef?.messages?.slice().reverse().find(m => m.role==='assistant' && m.agentId===agent.id && (m.status==='loading' || m.status==='thinking' || m.status==='streaming' || m.status==='empty' || m.status==='done' || m.status==='error' || m.status==='canceled'));
                if (last && (last.status === 'streaming' || last.status === 'thinking' || last.status === 'loading')) {
                    inflight.delete(last.id);
                    last.status = (error?.name === 'AbortError') ? 'canceled' : 'error';
                }
                saveData();
                renderMessages();
                if (error?.name !== 'AbortError') {
                    addSystemMessage(group, `è§’è‰² ${agent.name} å“åº”å¤±è´¥: ${error.message}`, 'error');
                }
            }
        }

        // å‘èŠå¤©åˆ—è¡¨æ’å…¥ç³»ç»Ÿæç¤ºï¼ˆå±…ä¸­ã€å¼±åŒ–ã€é¢œè‰²åŒºåˆ†ï¼‰
        function addSystemMessage(group, content, level = 'info') {
            if (!group) return;
            if (!group.messages) group.messages = [];
            group.messages.push({ role: 'system', content, level, timestamp: Date.now() });
            saveData();
            renderMessages();
        }

        function clearChat() {
            if (!currentGroupId) return;
            const group = groups.find(g => g.id === currentGroupId);
            if (!group) return;

            const previous = Array.isArray(group.messages) ? group.messages.slice() : [];
            group.messages = [];
            saveData();
            // åŒæ­¥æ¸…ç†æ¸²æŸ“ç¼“å­˜
            messageElementCache.clear();
            renderMessages();

            let undone = false;
            const undo = () => {
                if (undone) return; undone = true;
                group.messages = previous;
                saveData();
                renderMessages();
                showToast('å·²æ’¤é”€åˆ é™¤', 'info', 3000);
            };

            showToast('åˆ é™¤æˆåŠŸ', 'success', 6000, { text: 'æ’¤é”€', onClick: undo });
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function generateRandomColor() {
            const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#30cfd0', '#a8edea', '#ff6b6b', '#4ecdc4'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // åˆå¹¶ Agent ä¸å…¨å±€é…ç½®ï¼Œæœªå¡«å†™åˆ™å›é€€åˆ°å…¨å±€
        function resolveAgentConfig(agent, global) {
            const useGlobal = agent.useGlobal !== false;
            const base = useGlobal ? {} : agent;

            return {
                baseUrl: useGlobal ? global.baseUrl : (base.baseUrl || global.baseUrl),
                apiKey: useGlobal ? global.apiKey : (base.apiKey || global.apiKey),
                model: useGlobal ? global.model : (base.model || global.model),
                temperature: useGlobal ? (agent.temperature ?? 0.7) : (base.temperature ?? 0.7),
                maxTokens: useGlobal ? (agent.maxTokens ?? 2000) : (base.maxTokens ?? 2000)
            };
        }

        // è®¾ç½® Agent é…ç½®è¾“å…¥çš„å ä½ç¬¦/é»˜è®¤é€‰é¡¹
        function setAgentConfigPlaceholders(agentConfig) {
            if (el.agentBaseUrl) {
                el.agentBaseUrl.placeholder = globalSettings.baseUrl || 'https://api.openai.com/v1';
            }
            if (el.agentApiKey) {
                el.agentApiKey.placeholder = 'ç•™ç©ºä»¥ä½¿ç”¨å…¨å±€ API Key';
            }
            if (el.agentModel) {
                const desired = agentConfig ? agentConfig.model : (globalSettings.model || '');
                if (desired) {
                    const has = Array.from(el.agentModel.options).some(o => o.value === desired);
                    if (!has) {
                        const opt = document.createElement('option');
                        opt.value = desired;
                        opt.textContent = desired;
                        el.agentModel.appendChild(opt);
                    }
                    el.agentModel.value = desired;
                }
            }
        }

        // ==== Per-group Context Settings (Perspective & Vision) ====
        function ensureGroupAgentSettings(group) {
            if (!group.agentSettings) group.agentSettings = {};
            return group.agentSettings;
        }
        function getAgentGroupSettings(group, agentId) {
            const map = ensureGroupAgentSettings(group);
            if (!map[agentId]) {
                map[agentId] = {
                    perspective: { iCanSee: 'all', canSeeMe: 'all' },
                    vision: { type: 'all' }
                };
            } else {
                const p = map[agentId].perspective || (map[agentId].perspective = { iCanSee: 'all', canSeeMe: 'all' });
                if (!p.iCanSee) p.iCanSee = 'all';
                if (!p.canSeeMe) p.canSeeMe = 'all';
                const v = map[agentId].vision || (map[agentId].vision = { type: 'all' });
                if (!v.type) v.type = 'all';
            }
            return map[agentId];
        }
        function resolveGroupPerspective(agentId, group) {
            const s = getAgentGroupSettings(group, agentId);
            const gi = new Set(group.agentIds || []);
            let seen = new Set();
            if (s.perspective?.iCanSee === 'all') {
                seen = new Set(gi);
            } else if (Array.isArray(s.perspective?.iCanSee)) {
                seen = new Set((s.perspective.iCanSee || []).filter(id => gi.has(id)));
            }
            seen.add(agentId);
            return seen;
        }
        function messageVisibleToViewer(msg, viewerId) {
            if (msg.role !== 'assistant') return true;
            const vis = msg.visibleToAgentIds;
            if (!vis || vis === 'all') return true;
            if (Array.isArray(vis)) return vis.includes(viewerId);
            return true;
        }
        function parseVisionExpr(expr, len) {
            // New syntax: tokens like "1,2,8:0" or "-4:-1" or "9:" or ":0" or "1,3,-2"
            // Returns indices asc unique; on empty/invalid -> full range
            const full = Array.from({ length: len }, (_, i) => i);
            const s = String(expr || '').trim();
            if (!s) return full;
            const tokens = s.split(',').map(t => t.trim()).filter(Boolean);
            const out = new Set();
            let hadError = false;
            const toIdx = (v) => {
                let n = parseInt(v, 10);
                if (isNaN(n)) { hadError = true; return null; }
                if (n < 0) n = len + n;
                if (n < 0 || n >= len) { hadError = true; return null; }
                return n;
            };
            for (const tk of tokens) {
                if (tk.includes(':')) {
                    const [a, b] = tk.split(':');
                    // start
                    let start;
                    if (a.trim() === '') start = 0; else {
                        let n = parseInt(a.trim(), 10);
                        if (isNaN(n)) { hadError = true; continue; }
                        if (n < 0) n = len + n;
                        start = n;
                    }
                    // endExclusive
                    let endExc;
                    if (b.trim() === '' || b.trim() === '0') endExc = len; else {
                        let n = parseInt(b.trim(), 10);
                        if (isNaN(n)) { hadError = true; continue; }
                        if (n < 0) n = len + n;
                        endExc = n;
                    }
                    start = Math.max(0, Math.min(len, start));
                    endExc = Math.max(0, Math.min(len, endExc));
                    if (endExc <= start) { hadError = true; continue; }
                    for (let i = start; i < endExc; i++) out.add(i);
                } else {
                    const idx = toIdx(tk);
                    if (idx !== null) out.add(idx);
                }
            }
            if (out.size === 0) return hadError ? full : [];
            return Array.from(out).sort((a,b)=>a-b);
        }

        function validatePermVisionExprLive() {
            if (!el.permVisionExpr) return '';
            const val = el.permVisionExpr.value || '';
            const group = groups.find(g => g.id === currentGroupId);
            const nonSystemLen = (group?.messages||[]).filter(m=>m.role!=='system').length;
            let error = '';
            try {
                const idxs = parseVisionExpr(val, nonSystemLen);
                // rudimentary detection: if input non-empty and result equals full but had error is not exposed.
                // We'll re-validate tokens format with regex.
                const bad = val.split(',').map(t=>t.trim()).filter(Boolean).some(t=>!/^[-]?\d+$|^[-]?\d*:\s*[-]?\d*$/.test(t));
                if (bad) error = 'æ ¼å¼é”™è¯¯ï¼šä»…æ”¯æŒæ•°å­—æˆ– a:b å½¢å¼ï¼ˆæ”¯æŒè´Ÿæ•°ï¼‰ï¼Œç”¨é€—å·åˆ†éš”';
            } catch (_) {
                error = 'è§£æå¤±è´¥ï¼šè¯·æ£€æŸ¥è¯­æ³•';
            }
            if (el.permVisionError) {
                el.permVisionError.textContent = error;
                el.permVisionError.style.display = error ? '' : 'none';
            }
            return error;
        }
        function buildHistoryForAgentInGroup(agent, group) {
            const nonSystem = (group.messages || []).filter(m => m.role !== 'system' && !(m.role === 'assistant' && m.status === 'empty'));
            const settings = getAgentGroupSettings(group, agent.id);
            let indices;
            if (!settings.vision || settings.vision.type === 'all') {
                indices = Array.from({ length: nonSystem.length }, (_, i) => i);
            } else if (settings.vision.type === 'last1') {
                indices = nonSystem.length > 0 ? [nonSystem.length - 1] : [];
            } else if (settings.vision.type === 'custom') {
                indices = parseVisionExpr(settings.vision.expr, nonSystem.length);
            } else {
                indices = Array.from({ length: nonSystem.length }, (_, i) => i);
            }
            const base = indices.map(i => nonSystem[i]).filter(Boolean);
            const canSee = resolveGroupPerspective(agent.id, group);
            const filtered = base.filter(m => {
                if (m.role === 'user') return true;
                if (m.role === 'assistant') {
                    if (!canSee.has(m.agentId)) return false;
                    return messageVisibleToViewer(m, agent.id);
                }
                return false;
            });
            const mapped = filtered.map(msg => {
                if (msg.role === 'user') {
                    return { role: 'user', content: `[${globalSettings.userName}]: ${msg.content}` };
                } else {
                    const msgAgent = agents.find(a => a.id === msg.agentId);
                    const agentName = msgAgent ? msgAgent.name : 'æœªçŸ¥';
                    if (msg.agentId === agent.id) {
                        return { role: 'assistant', content: `[${agentName}]: ${msg.content}` };
                    } else {
                        return { role: 'user', content: `[${agentName}]: ${msg.content}` };
                    }
                }
            });
            const otherNames = (group.agentIds||[]).map(id => agents.find(a=>a.id===id)).filter(a=>a&&a.id!==agent.id).map(a=>a.name).join(', ');
            const rule = `è¯·ä½ ä»¥ä½ çš„èº«ä»½è‡ªç„¶åœ°å›å¤å¯¹è¯ã€‚ç¦æ­¢é¡¹: ç¦æ­¢åœ¨å›å¤é‡Œå‡ºç°ä½ çš„åå­—ã€‚
----
[è¾“å‡ºè§„åˆ™] æ ¼å¼çº¯å‡€æ€§ (Format Purity): ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»ç›´æ¥ä»¥å†…å®¹å¼€å§‹ã€‚ä¸¥ç¦åœ¨å›å¤çš„å¼€å¤´æ·»åŠ ä»»ä½•å½¢å¼çš„èº«ä»½æ ‡è¯†ã€åç§°æˆ–å‰ç¼€ï¼Œä¾‹å¦‚ '[${agent.name}]:'ã€'${agent.name}:' æˆ– '[AI]:'.`;
            mapped.unshift({
                role: 'system',
                content: `ä½ çš„åå­—æ˜¯ ${agent.name}${agent.role ? 'ï¼Œ' + agent.role : ''}ã€‚${agent.prompt}\n\nè¿™æ˜¯ä¸€ä¸ªç¾¤èŠç¯å¢ƒï¼Œå‚ä¸è€…åŒ…æ‹¬: ${globalSettings.userName}${otherNames ? ', ' + otherNames : ''}ã€‚` + rule
            });
            return mapped;
        }

        function isMobileView() {
            return window.matchMedia('(max-width: 768px)').matches;
        }

        function applyDefaultSidebarHiddenIfNonDesktop() {
            const hasLeft = localStorage.getItem('sidebarHidden');
            const hasRight = localStorage.getItem('sidebarRightHidden');
            if (!isMobileView()) return;
            if (hasLeft === null && hasRight === null) {
                const left = qs('.sidebar');
                const right = qs('.sidebar-right');
                if (left && !left.classList.contains('hidden')) left.classList.add('hidden');
                if (right && !right.classList.contains('hidden')) right.classList.add('hidden');
                localStorage.setItem('sidebarHidden', 'true');
                localStorage.setItem('sidebarRightHidden', 'true');
            }
        }

        function updateMobileSidebarState() {
            if (!el.sidebarOverlay) return;

            if (!isMobileView()) {
                el.sidebarOverlay.classList.remove('active');
                return;
            }

            const leftOpen = !qs('.sidebar').classList.contains('hidden');
            const rightOpen = !qs('.sidebar-right').classList.contains('hidden');

            if (leftOpen || rightOpen) {
                el.sidebarOverlay.classList.add('active');
            } else {
                el.sidebarOverlay.classList.remove('active');
            }
        }

        // Desktop: reflect sidebar open state by pushing main content
        function updateDesktopPushState() {
            if (isMobileView()) return;
            const container = qs('.container');
            const leftOpen = !qs('.sidebar').classList.contains('hidden');
            const rightOpen = !qs('.sidebar-right').classList.contains('hidden');
            container.classList.toggle('left-open', leftOpen);
            container.classList.toggle('right-open', rightOpen);
        }

        function closeMobileSidebars() {
            if (!isMobileView() || !el.sidebarOverlay) return;

            const leftSidebar = qs('.sidebar');
            const rightSidebar = qs('.sidebar-right');
            let changed = false;

            if (!leftSidebar.classList.contains('hidden')) {
                leftSidebar.classList.add('hidden');
                localStorage.setItem('sidebarHidden', 'true');
                changed = true;
            }

            if (!rightSidebar.classList.contains('hidden')) {
                rightSidebar.classList.add('hidden');
                localStorage.setItem('sidebarRightHidden', 'true');
                changed = true;
            }

            if (changed || el.sidebarOverlay.classList.contains('active')) {
                updateMobileSidebarState();
            }
        }

        function handleGlobalKeydown(e) {
            if (e.key === 'Escape') {
                if (closeTopModal()) {
                    e.preventDefault();
                    return;
                }
                closeMobileSidebars();
            }
        }

        function closeTopModal() {
            const actives = qsa('.modal.active');
            if (actives.length > 0) {
                const top = actives[actives.length - 1];
                top.classList.remove('active');
                return true;
            }
            return false;
        }

        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function toggleSidebar() {
            const sidebar = qs('.sidebar');
            sidebar.classList.toggle('hidden');
            localStorage.setItem('sidebarHidden', sidebar.classList.contains('hidden'));
            updateMobileSidebarState();
            updateDesktopPushState();
        }

        function toggleRightSidebar() {
            const sidebarRight = qs('.sidebar-right');
            sidebarRight.classList.toggle('hidden');
            localStorage.setItem('sidebarRightHidden', sidebarRight.classList.contains('hidden'));
            updateMobileSidebarState();
            updateDesktopPushState();
        }

        function restoreSidebarState() {
            const isSidebarHidden = localStorage.getItem('sidebarHidden') === 'true';
            const isRightSidebarHidden = localStorage.getItem('sidebarRightHidden') === 'true';
            
            if (isSidebarHidden) {
                qs('.sidebar').classList.add('hidden');
            }
            if (isRightSidebarHidden) {
                qs('.sidebar-right').classList.add('hidden');
            }

            updateMobileSidebarState();
            updateDesktopPushState();
        }

        // è‹¥æœªé€‰ä¸­ä»»ä½•ç¾¤èŠï¼Œåˆ™é»˜è®¤é€‰ä¸­åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ª
        function autoSelectFirstGroupIfNone() {
            if (!currentGroupId && Array.isArray(groups) && groups.length > 0) {
                selectGroup(groups[0].id);
            }
        }

        // å¯åŠ¨æ—¶å°è¯•è‡ªåŠ¨è¿›å…¥ä¸Šæ¬¡é€€å‡ºçš„ç¾¤èŠ
        function autoEnterLastGroup() {
            const lastId = localStorage.getItem('lastGroupId_v1');
            if (!lastId) return;
            if (!groups || groups.length === 0) return;
            if (groups.some(g => g.id === lastId)) {
                selectGroup(lastId);
            }
        }

        init();
        restoreSidebarState();
        applyDefaultSidebarHiddenIfNonDesktop();
        updateMobileSidebarState();
        updateDesktopPushState();
    </script>
</body>
</html>
